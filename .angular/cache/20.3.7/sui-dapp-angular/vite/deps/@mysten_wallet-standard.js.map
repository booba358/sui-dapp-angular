{
  "version": 3,
  "sources": ["../../../../../../node_modules/@wallet-standard/app/lib/esm/wallets.js", "../../../../../../node_modules/@wallet-standard/errors/lib/esm/codes.js", "../../../../../../node_modules/@wallet-standard/errors/lib/esm/messages.js", "../../../../../../node_modules/@wallet-standard/errors/lib/esm/message-formatter.js", "../../../../../../node_modules/@wallet-standard/errors/lib/esm/error.js", "../../../../../../node_modules/@wallet-standard/errors/lib/esm/stack-trace.js", "../../../../../../node_modules/@wallet-standard/features/lib/esm/connect.js", "../../../../../../node_modules/@wallet-standard/features/lib/esm/disconnect.js", "../../../../../../node_modules/@wallet-standard/features/lib/esm/events.js", "../../../../../../node_modules/@wallet-standard/wallet/lib/esm/register.js", "../../../../../../node_modules/@wallet-standard/wallet/lib/esm/util.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/Arguments.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/wallet.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignMessage.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignTransactionBlock.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignTransaction.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignAndExecuteTransactionBlock.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignAndExecuteTransaction.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiSignPersonalMessage.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiReportTransactionEffects.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/features/suiGetCapabilities.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/detect.js", "../../../../../../node_modules/@mysten/wallet-standard/dist/esm/chains.js"],
  "sourcesContent": ["var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AppReadyEvent_detail;\nlet wallets = undefined;\nconst registeredWalletsSet = new Set();\nfunction addRegisteredWallet(wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.add(wallet);\n}\nfunction removeRegisteredWallet(wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.delete(wallet);\n}\nconst listeners = {};\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\nexport function getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = Object.freeze({ register, get, on });\n    if (typeof window === 'undefined')\n        return wallets;\n    const api = Object.freeze({ register });\n    try {\n        window.addEventListener('wallet-standard:register-wallet', ({ detail: callback }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n    }\n    try {\n        window.dispatchEvent(new AppReadyEvent(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n    }\n    return wallets;\n}\nfunction register(...wallets) {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet) => !registeredWalletsSet.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length)\n        return () => { };\n    wallets.forEach((wallet) => addRegisteredWallet(wallet));\n    listeners['register']?.forEach((listener) => guard(() => listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister() {\n        wallets.forEach((wallet) => removeRegisteredWallet(wallet));\n        listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)));\n    };\n}\nlet cachedWalletsArray;\nfunction get() {\n    if (!cachedWalletsArray) {\n        cachedWalletsArray = [...registeredWalletsSet];\n    }\n    return cachedWalletsArray;\n}\nfunction on(event, listener) {\n    listeners[event]?.push(listener) || (listeners[event] = [listener]);\n    // Return a function that removes the event listener.\n    return function off() {\n        listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);\n    };\n}\nfunction guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nclass AppReadyEvent extends Event {\n    get detail() {\n        return __classPrivateFieldGet(this, _AppReadyEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:app-ready';\n    }\n    constructor(api) {\n        super('wallet-standard:app-ready', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _AppReadyEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _AppReadyEvent_detail, api, \"f\");\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_AppReadyEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = getWallets();\n    if (typeof window === 'undefined')\n        return wallets;\n    const callbacks = window.navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error('window.navigator.wallets is not an array');\n        return wallets;\n    }\n    const { register } = wallets;\n    const push = (...callbacks) => callbacks.forEach((callback) => guard(() => callback({ register })));\n    try {\n        Object.defineProperty(window.navigator, 'wallets', {\n            value: Object.freeze({ push }),\n        });\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be set');\n        return wallets;\n    }\n    push(...callbacks);\n    return wallets;\n}\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/wallet-standard/wallet-standard/tree/master/packages/core/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `WALLET_STANDARD_ERROR__ACCOUNT__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\n// Registry-related errors.\n// Reserve error codes in the range [3834000-3834999].\nexport const WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834000;\nexport const WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001;\n// User-related errors.\n// Reserve error codes in the range [4001000-4001999].\nexport const WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001000;\n// Feature-related errors.\n// Reserve error codes in the range [6160000-6160999].\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 6160000;\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001;\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002;\n", "import { WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED, WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED, WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED, WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND, WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND, WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED, } from './codes.js';\n/**\n * To add a new error, follow the instructions at\n * https://github.com/wallet-standard/wallet-standard/tree/master/packages/core/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const WalletStandardErrorMessages = {\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]: 'The wallet account $address does not support the chain `$chain`',\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]: 'The wallet account $address does not support the `$featureName` feature',\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]: \"The wallet '$walletName' does not support the `$featureName` feature\",\n    [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]: \"No account with address $address could be found in the '$walletName' wallet\",\n    [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]: 'No underlying Wallet Standard wallet could be found for this handle. This can happen if ' +\n        'the wallet associated with the handle has been unregistered.',\n    [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: 'The user rejected the request',\n};\n", "import { encodeContextObject } from './context.js';\nimport { WalletStandardErrorMessages } from './messages.js';\nvar StateType;\n(function (StateType) {\n    StateType[StateType[\"EscapeSequence\"] = 0] = \"EscapeSequence\";\n    StateType[StateType[\"Text\"] = 1] = \"Text\";\n    StateType[StateType[\"Variable\"] = 2] = \"Variable\";\n})(StateType || (StateType = {}));\nconst START_INDEX = 'i';\nconst TYPE = 't';\nexport function getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = WalletStandardErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);\n        }\n        else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === '\\\\'\n                    ? StateType.EscapeSequence\n                    : messageFormatString[0] === '$'\n                        ? StateType.Variable\n                        : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                }\n                else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                }\n                else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\nexport function getErrorMessage(code, context = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n        return getHumanReadableErrorMessage(code, context);\n    }\n    else {\n        let decodingAdviceMessage = `Wallet Standard error #${code}; Decode this error by running \\`npx @wallet-standard/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n", "import { getErrorMessage } from './message-formatter.js';\nexport function isWalletStandardError(e, code) {\n    const isWalletStandardError = e instanceof Error && e.name === 'WalletStandardError';\n    if (isWalletStandardError) {\n        if (code !== undefined) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nexport class WalletStandardError extends Error {\n    constructor(...[code, contextAndErrorOptions]) {\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest;\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        };\n        // This is necessary so that `isWalletStandardError()` can identify a `WalletStandardError`\n        // without having to import the class for use in an `instanceof` check.\n        this.name = 'WalletStandardError';\n    }\n}\n", "export function safeCaptureStackTrace(...args) {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n", "/** Name of the feature. */\nexport const StandardConnect = 'standard:connect';\n/**\n * @deprecated Use {@link StandardConnect} instead.\n *\n * @group Deprecated\n */\nexport const Connect = StandardConnect;\n", "/** Name of the feature. */\nexport const StandardDisconnect = 'standard:disconnect';\n/**\n * @deprecated Use {@link StandardDisconnect} instead.\n *\n * @group Deprecated\n */\nexport const Disconnect = StandardDisconnect;\n", "/** Name of the feature. */\nexport const StandardEvents = 'standard:events';\n/**\n * @deprecated Use {@link StandardEvents} instead.\n *\n * @group Deprecated\n */\nexport const Events = StandardEvents;\n", "var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _RegisterWalletEvent_detail;\n/**\n * Register a {@link \"@wallet-standard/base\".Wallet} as a Standard Wallet with the app.\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to notify the app that the Wallet is\n * ready to be registered.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowAppReadyEvent} to listen for a notification from\n * the app that the app is ready to register the Wallet.\n *\n * This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon\n * as the app is ready whether the Wallet loads before or after the app.\n *\n * @param wallet Wallet to register.\n *\n * @group Wallet\n */\nexport function registerWallet(wallet) {\n    const callback = ({ register }) => register(wallet);\n    try {\n        window.dispatchEvent(new RegisterWalletEvent(callback));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event could not be dispatched\\n', error);\n    }\n    try {\n        window.addEventListener('wallet-standard:app-ready', ({ detail: api }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event listener could not be added\\n', error);\n    }\n}\nclass RegisterWalletEvent extends Event {\n    get detail() {\n        return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:register-wallet';\n    }\n    constructor(callback) {\n        super('wallet-standard:register-wallet', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _RegisterWalletEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _RegisterWalletEvent_detail, callback, \"f\");\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_RegisterWalletEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link registerWallet} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_registerWallet(wallet) {\n    var _a;\n    registerWallet(wallet);\n    try {\n        ((_a = window.navigator).wallets || (_a.wallets = [])).push(({ register }) => register(wallet));\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be pushed\\n', error);\n    }\n}\n", "var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nexport class ReadonlyWalletAccount {\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n    get address() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n    get publicKey() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n    get chains() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n    get features() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n    get label() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n    get icon() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, \"f\");\n    }\n    /**\n     * Create and freeze a read-only account.\n     *\n     * @param account Account to copy properties from.\n     */\n    constructor(account) {\n        _ReadonlyWalletAccount_address.set(this, void 0);\n        _ReadonlyWalletAccount_publicKey.set(this, void 0);\n        _ReadonlyWalletAccount_chains.set(this, void 0);\n        _ReadonlyWalletAccount_features.set(this, void 0);\n        _ReadonlyWalletAccount_label.set(this, void 0);\n        _ReadonlyWalletAccount_icon.set(this, void 0);\n        if (new.target === ReadonlyWalletAccount) {\n            Object.freeze(this);\n        }\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, \"f\");\n    }\n}\n_ReadonlyWalletAccount_address = new WeakMap(), _ReadonlyWalletAccount_publicKey = new WeakMap(), _ReadonlyWalletAccount_chains = new WeakMap(), _ReadonlyWalletAccount_features = new WeakMap(), _ReadonlyWalletAccount_label = new WeakMap(), _ReadonlyWalletAccount_icon = new WeakMap();\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nexport function arraysEqual(a, b) {\n    if (a === b)\n        return true;\n    const length = a.length;\n    if (length !== b.length)\n        return false;\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nexport function bytesEqual(a, b) {\n    return arraysEqual(a, b);\n}\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nexport function concatBytes(first, ...others) {\n    const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n    const bytes = new Uint8Array(length);\n    bytes.set(first, 0);\n    for (const other of others) {\n        bytes.set(other, bytes.length);\n    }\n    return bytes;\n}\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nexport function pick(source, ...keys) {\n    const picked = {};\n    for (const key of keys) {\n        picked[key] = source[key];\n    }\n    return picked;\n}\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nexport function guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _caches, _cache, _onEffects;\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nclass AsyncCache {\n  async getObject(id) {\n    const [owned, shared] = await Promise.all([\n      this.get(\"OwnedObject\", id),\n      this.get(\"SharedOrImmutableObject\", id)\n    ]);\n    return owned ?? shared ?? null;\n  }\n  async getObjects(ids) {\n    return Promise.all(ids.map((id) => this.getObject(id)));\n  }\n  async addObject(object) {\n    if (object.owner) {\n      await this.set(\"OwnedObject\", object.objectId, object);\n    } else {\n      await this.set(\"SharedOrImmutableObject\", object.objectId, object);\n    }\n    return object;\n  }\n  async addObjects(objects) {\n    await Promise.all(objects.map(async (object) => this.addObject(object)));\n  }\n  async deleteObject(id) {\n    await Promise.all([this.delete(\"OwnedObject\", id), this.delete(\"SharedOrImmutableObject\", id)]);\n  }\n  async deleteObjects(ids) {\n    await Promise.all(ids.map((id) => this.deleteObject(id)));\n  }\n  async getMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    return this.get(\"MoveFunction\", functionName);\n  }\n  async addMoveFunctionDefinition(functionEntry) {\n    const pkg = normalizeSuiAddress(functionEntry.package);\n    const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n    const entry = {\n      ...functionEntry,\n      package: pkg\n    };\n    await this.set(\"MoveFunction\", functionName, entry);\n    return entry;\n  }\n  async deleteMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    await this.delete(\"MoveFunction\", functionName);\n  }\n  async getCustom(key) {\n    return this.get(\"Custom\", key);\n  }\n  async setCustom(key, value) {\n    return this.set(\"Custom\", key, value);\n  }\n  async deleteCustom(key) {\n    return this.delete(\"Custom\", key);\n  }\n}\nclass InMemoryCache extends AsyncCache {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _caches, {\n      OwnedObject: /* @__PURE__ */ new Map(),\n      SharedOrImmutableObject: /* @__PURE__ */ new Map(),\n      MoveFunction: /* @__PURE__ */ new Map(),\n      Custom: /* @__PURE__ */ new Map()\n    });\n  }\n  async get(type, key) {\n    return __privateGet(this, _caches)[type].get(key) ?? null;\n  }\n  async set(type, key, value) {\n    __privateGet(this, _caches)[type].set(key, value);\n  }\n  async delete(type, key) {\n    __privateGet(this, _caches)[type].delete(key);\n  }\n  async clear(type) {\n    if (type) {\n      __privateGet(this, _caches)[type].clear();\n    } else {\n      for (const cache of Object.values(__privateGet(this, _caches))) {\n        cache.clear();\n      }\n    }\n  }\n}\n_caches = new WeakMap();\nclass ObjectCache {\n  constructor({ cache = new InMemoryCache(), onEffects }) {\n    __privateAdd(this, _cache);\n    __privateAdd(this, _onEffects);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _onEffects, onEffects);\n  }\n  asPlugin() {\n    return async (transactionData, _options, next) => {\n      const unresolvedObjects = transactionData.inputs.filter((input) => input.UnresolvedObject).map((input) => input.UnresolvedObject.objectId);\n      const cached = (await __privateGet(this, _cache).getObjects(unresolvedObjects)).filter(\n        (obj) => obj !== null\n      );\n      const byId = new Map(cached.map((obj) => [obj.objectId, obj]));\n      for (const input of transactionData.inputs) {\n        if (!input.UnresolvedObject) {\n          continue;\n        }\n        const cached2 = byId.get(input.UnresolvedObject.objectId);\n        if (!cached2) {\n          continue;\n        }\n        if (cached2.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n          input.UnresolvedObject.initialSharedVersion = cached2.initialSharedVersion;\n        } else {\n          if (cached2.version && !input.UnresolvedObject.version) {\n            input.UnresolvedObject.version = cached2.version;\n          }\n          if (cached2.digest && !input.UnresolvedObject.digest) {\n            input.UnresolvedObject.digest = cached2.digest;\n          }\n        }\n      }\n      await Promise.all(\n        transactionData.commands.map(async (commands) => {\n          if (commands.MoveCall) {\n            const def = await this.getMoveFunctionDefinition({\n              package: commands.MoveCall.package,\n              module: commands.MoveCall.module,\n              function: commands.MoveCall.function\n            });\n            if (def) {\n              commands.MoveCall._argumentTypes = def.parameters;\n            }\n          }\n        })\n      );\n      await next();\n      await Promise.all(\n        transactionData.commands.map(async (commands) => {\n          if (commands.MoveCall?._argumentTypes) {\n            await __privateGet(this, _cache).addMoveFunctionDefinition({\n              package: commands.MoveCall.package,\n              module: commands.MoveCall.module,\n              function: commands.MoveCall.function,\n              parameters: commands.MoveCall._argumentTypes\n            });\n          }\n        })\n      );\n    };\n  }\n  async clear() {\n    await __privateGet(this, _cache).clear();\n  }\n  async getMoveFunctionDefinition(ref) {\n    return __privateGet(this, _cache).getMoveFunctionDefinition(ref);\n  }\n  async getObjects(ids) {\n    return __privateGet(this, _cache).getObjects(ids);\n  }\n  async deleteObjects(ids) {\n    return __privateGet(this, _cache).deleteObjects(ids);\n  }\n  async clearOwnedObjects() {\n    await __privateGet(this, _cache).clear(\"OwnedObject\");\n  }\n  async clearCustom() {\n    await __privateGet(this, _cache).clear(\"Custom\");\n  }\n  async getCustom(key) {\n    return __privateGet(this, _cache).getCustom(key);\n  }\n  async setCustom(key, value) {\n    return __privateGet(this, _cache).setCustom(key, value);\n  }\n  async deleteCustom(key) {\n    return __privateGet(this, _cache).deleteCustom(key);\n  }\n  async applyEffects(effects) {\n    var _a;\n    if (!effects.V2) {\n      throw new Error(`Unsupported transaction effects version ${effects.$kind}`);\n    }\n    const { lamportVersion, changedObjects } = effects.V2;\n    const deletedIds = [];\n    const addedObjects = [];\n    changedObjects.forEach(([id, change]) => {\n      if (change.outputState.NotExist) {\n        deletedIds.push(id);\n      } else if (change.outputState.ObjectWrite) {\n        const [digest, owner] = change.outputState.ObjectWrite;\n        addedObjects.push({\n          objectId: id,\n          digest,\n          version: lamportVersion,\n          owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n          initialSharedVersion: owner.Shared?.initialSharedVersion ?? null\n        });\n      }\n    });\n    await Promise.all([\n      __privateGet(this, _cache).addObjects(addedObjects),\n      __privateGet(this, _cache).deleteObjects(deletedIds),\n      (_a = __privateGet(this, _onEffects)) == null ? void 0 : _a.call(this, effects)\n    ]);\n  }\n}\n_cache = new WeakMap();\n_onEffects = new WeakMap();\nexport {\n  AsyncCache,\n  InMemoryCache,\n  ObjectCache\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _client, _lastDigest;\nimport { bcs } from \"../../bcs/index.js\";\nimport { ObjectCache } from \"../ObjectCache.js\";\nimport { isTransaction } from \"../Transaction.js\";\nclass CachingTransactionExecutor {\n  constructor({\n    client,\n    ...options\n  }) {\n    __privateAdd(this, _client);\n    __privateAdd(this, _lastDigest, null);\n    __privateSet(this, _client, client);\n    this.cache = new ObjectCache(options);\n  }\n  /**\n   * Clears all Owned objects\n   * Immutable objects, Shared objects, and Move function definitions will be preserved\n   */\n  async reset() {\n    await Promise.all([\n      this.cache.clearOwnedObjects(),\n      this.cache.clearCustom(),\n      this.waitForLastTransaction()\n    ]);\n  }\n  async buildTransaction({\n    transaction,\n    ...options\n  }) {\n    transaction.addBuildPlugin(this.cache.asPlugin());\n    return transaction.build({\n      client: __privateGet(this, _client),\n      ...options\n    });\n  }\n  async executeTransaction({\n    transaction,\n    options,\n    ...input\n  }) {\n    const bytes = isTransaction(transaction) ? await this.buildTransaction({ transaction }) : transaction;\n    const results = await __privateGet(this, _client).executeTransactionBlock({\n      ...input,\n      transactionBlock: bytes,\n      options: {\n        ...options,\n        showRawEffects: true\n      }\n    });\n    if (results.rawEffects) {\n      const effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n      await this.applyEffects(effects);\n    }\n    return results;\n  }\n  async signAndExecuteTransaction({\n    options,\n    transaction,\n    ...input\n  }) {\n    transaction.setSenderIfNotSet(input.signer.toSuiAddress());\n    const bytes = await this.buildTransaction({ transaction });\n    const { signature } = await input.signer.signTransaction(bytes);\n    const results = await this.executeTransaction({\n      transaction: bytes,\n      signature,\n      options\n    });\n    return results;\n  }\n  async applyEffects(effects) {\n    __privateSet(this, _lastDigest, effects.V2?.transactionDigest ?? null);\n    await this.cache.applyEffects(effects);\n  }\n  async waitForLastTransaction() {\n    if (__privateGet(this, _lastDigest)) {\n      await __privateGet(this, _client).waitForTransaction({ digest: __privateGet(this, _lastDigest) });\n      __privateSet(this, _lastDigest, null);\n    }\n  }\n}\n_client = new WeakMap();\n_lastDigest = new WeakMap();\nexport {\n  CachingTransactionExecutor\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar _queue, _queue2;\nclass SerialQueue {\n  constructor() {\n    __privateAdd(this, _queue, []);\n  }\n  async runTask(task) {\n    return new Promise((resolve, reject) => {\n      __privateGet(this, _queue).push(() => {\n        task().finally(() => {\n          __privateGet(this, _queue).shift();\n          if (__privateGet(this, _queue).length > 0) {\n            __privateGet(this, _queue)[0]();\n          }\n        }).then(resolve, reject);\n      });\n      if (__privateGet(this, _queue).length === 1) {\n        __privateGet(this, _queue)[0]();\n      }\n    });\n  }\n}\n_queue = new WeakMap();\nclass ParallelQueue {\n  constructor(maxTasks) {\n    __privateAdd(this, _queue2, []);\n    this.activeTasks = 0;\n    this.maxTasks = maxTasks;\n  }\n  runTask(task) {\n    return new Promise((resolve, reject) => {\n      if (this.activeTasks < this.maxTasks) {\n        this.activeTasks++;\n        task().finally(() => {\n          if (__privateGet(this, _queue2).length > 0) {\n            __privateGet(this, _queue2).shift()();\n          } else {\n            this.activeTasks--;\n          }\n        }).then(resolve, reject);\n      } else {\n        __privateGet(this, _queue2).push(() => {\n          task().finally(() => {\n            if (__privateGet(this, _queue2).length > 0) {\n              __privateGet(this, _queue2).shift()();\n            } else {\n              this.activeTasks--;\n            }\n          }).then(resolve, reject);\n        });\n      }\n    });\n  }\n}\n_queue2 = new WeakMap();\nexport {\n  ParallelQueue,\n  SerialQueue\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _queue, _signer, _cache, _defaultGasBudget, _cacheGasCoin, _buildTransaction;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { isTransaction, Transaction } from \"../Transaction.js\";\nimport { CachingTransactionExecutor } from \"./caching.js\";\nimport { SerialQueue } from \"./queue.js\";\nclass SerialTransactionExecutor {\n  constructor({\n    signer,\n    defaultGasBudget = 50000000n,\n    ...options\n  }) {\n    __privateAdd(this, _queue, new SerialQueue());\n    __privateAdd(this, _signer);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _defaultGasBudget);\n    __privateAdd(this, _cacheGasCoin, async (effects) => {\n      if (!effects.V2) {\n        return;\n      }\n      const gasCoin = getGasCoinFromEffects(effects).ref;\n      if (gasCoin) {\n        __privateGet(this, _cache).cache.setCustom(\"gasCoin\", gasCoin);\n      } else {\n        __privateGet(this, _cache).cache.deleteCustom(\"gasCoin\");\n      }\n    });\n    __privateAdd(this, _buildTransaction, async (transaction) => {\n      const gasCoin = await __privateGet(this, _cache).cache.getCustom(\"gasCoin\");\n      const copy = Transaction.from(transaction);\n      if (gasCoin) {\n        copy.setGasPayment([gasCoin]);\n      }\n      copy.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));\n      copy.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());\n      return __privateGet(this, _cache).buildTransaction({ transaction: copy });\n    });\n    __privateSet(this, _signer, signer);\n    __privateSet(this, _defaultGasBudget, defaultGasBudget);\n    __privateSet(this, _cache, new CachingTransactionExecutor({\n      client: options.client,\n      cache: options.cache,\n      onEffects: (effects) => __privateGet(this, _cacheGasCoin).call(this, effects)\n    }));\n  }\n  async applyEffects(effects) {\n    return __privateGet(this, _cache).applyEffects(effects);\n  }\n  async buildTransaction(transaction) {\n    return __privateGet(this, _queue).runTask(() => __privateGet(this, _buildTransaction).call(this, transaction));\n  }\n  resetCache() {\n    return __privateGet(this, _cache).reset();\n  }\n  waitForLastTransaction() {\n    return __privateGet(this, _cache).waitForLastTransaction();\n  }\n  executeTransaction(transaction, options, additionalSignatures = []) {\n    return __privateGet(this, _queue).runTask(async () => {\n      const bytes = isTransaction(transaction) ? await __privateGet(this, _buildTransaction).call(this, transaction) : transaction;\n      const { signature } = await __privateGet(this, _signer).signTransaction(bytes);\n      const results = await __privateGet(this, _cache).executeTransaction({\n        signature: [signature, ...additionalSignatures],\n        transaction: bytes,\n        options\n      }).catch(async (error) => {\n        await this.resetCache();\n        throw error;\n      });\n      const effectsBytes = Uint8Array.from(results.rawEffects);\n      return {\n        digest: results.digest,\n        effects: toBase64(effectsBytes),\n        data: results\n      };\n    });\n  }\n}\n_queue = new WeakMap();\n_signer = new WeakMap();\n_cache = new WeakMap();\n_defaultGasBudget = new WeakMap();\n_cacheGasCoin = new WeakMap();\n_buildTransaction = new WeakMap();\nfunction getGasCoinFromEffects(effects) {\n  if (!effects.V2) {\n    throw new Error(\"Unexpected effects version\");\n  }\n  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];\n  if (!gasObjectChange) {\n    throw new Error(\"Gas object not found in effects\");\n  }\n  const [objectId, { outputState }] = gasObjectChange;\n  if (!outputState.ObjectWrite) {\n    throw new Error(\"Unexpected gas object state\");\n  }\n  const [digest, owner] = outputState.ObjectWrite;\n  return {\n    ref: {\n      objectId,\n      digest,\n      version: effects.V2.lamportVersion\n    },\n    owner: owner.AddressOwner || owner.ObjectOwner\n  };\n}\nexport {\n  SerialTransactionExecutor,\n  getGasCoinFromEffects\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _epochBoundaryWindow, _defaultGasBudget, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _lastDigest, _cacheLock, _pendingTransactions, _gasPrice, _ParallelTransactionExecutor_instances, getUsedObjects_fn, execute_fn, updateCache_fn, waitForLastDigest_fn, getGasCoin_fn, getGasPrice_fn, refillCoinPool_fn;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { promiseWithResolvers } from \"@mysten/utils\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { Transaction } from \"../Transaction.js\";\nimport { TransactionDataBuilder } from \"../TransactionData.js\";\nimport { CachingTransactionExecutor } from \"./caching.js\";\nimport { ParallelQueue, SerialQueue } from \"./queue.js\";\nimport { getGasCoinFromEffects } from \"./serial.js\";\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n  coinBatchSize: 20,\n  initialCoinBalance: 200000000n,\n  minimumCoinBalance: 50000000n,\n  maxPoolSize: 50,\n  epochBoundaryWindow: 1e3\n};\nclass ParallelTransactionExecutor {\n  constructor(options) {\n    __privateAdd(this, _ParallelTransactionExecutor_instances);\n    __privateAdd(this, _signer);\n    __privateAdd(this, _client);\n    __privateAdd(this, _coinBatchSize);\n    __privateAdd(this, _initialCoinBalance);\n    __privateAdd(this, _minimumCoinBalance);\n    __privateAdd(this, _epochBoundaryWindow);\n    __privateAdd(this, _defaultGasBudget);\n    __privateAdd(this, _maxPoolSize);\n    __privateAdd(this, _sourceCoins);\n    __privateAdd(this, _coinPool, []);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _objectIdQueues, /* @__PURE__ */ new Map());\n    __privateAdd(this, _buildQueue, new SerialQueue());\n    __privateAdd(this, _executeQueue);\n    __privateAdd(this, _lastDigest, null);\n    __privateAdd(this, _cacheLock, null);\n    __privateAdd(this, _pendingTransactions, 0);\n    __privateAdd(this, _gasPrice, null);\n    __privateSet(this, _signer, options.signer);\n    __privateSet(this, _client, options.client);\n    __privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);\n    __privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);\n    __privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);\n    __privateSet(this, _defaultGasBudget, options.defaultGasBudget ?? __privateGet(this, _minimumCoinBalance));\n    __privateSet(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);\n    __privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);\n    __privateSet(this, _cache, new CachingTransactionExecutor({\n      client: options.client,\n      cache: options.cache\n    }));\n    __privateSet(this, _executeQueue, new ParallelQueue(__privateGet(this, _maxPoolSize)));\n    __privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map((id) => [id, null])) : null);\n  }\n  resetCache() {\n    __privateSet(this, _gasPrice, null);\n    return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet(this, _cache).reset());\n  }\n  async waitForLastTransaction() {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));\n  }\n  async executeTransaction(transaction, options, additionalSignatures = []) {\n    const { promise, resolve, reject } = promiseWithResolvers();\n    const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);\n    const execute = () => {\n      __privateGet(this, _executeQueue).runTask(() => {\n        const promise2 = __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options, additionalSignatures);\n        return promise2.then(resolve, reject);\n      });\n    };\n    const conflicts = /* @__PURE__ */ new Set();\n    usedObjects.forEach((objectId) => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue) {\n        conflicts.add(objectId);\n        __privateGet(this, _objectIdQueues).get(objectId).push(() => {\n          conflicts.delete(objectId);\n          if (conflicts.size === 0) {\n            execute();\n          }\n        });\n      } else {\n        __privateGet(this, _objectIdQueues).set(objectId, []);\n      }\n    });\n    if (conflicts.size === 0) {\n      execute();\n    }\n    return promise;\n  }\n}\n_signer = new WeakMap();\n_client = new WeakMap();\n_coinBatchSize = new WeakMap();\n_initialCoinBalance = new WeakMap();\n_minimumCoinBalance = new WeakMap();\n_epochBoundaryWindow = new WeakMap();\n_defaultGasBudget = new WeakMap();\n_maxPoolSize = new WeakMap();\n_sourceCoins = new WeakMap();\n_coinPool = new WeakMap();\n_cache = new WeakMap();\n_objectIdQueues = new WeakMap();\n_buildQueue = new WeakMap();\n_executeQueue = new WeakMap();\n_lastDigest = new WeakMap();\n_cacheLock = new WeakMap();\n_pendingTransactions = new WeakMap();\n_gasPrice = new WeakMap();\n_ParallelTransactionExecutor_instances = new WeakSet();\ngetUsedObjects_fn = async function(transaction) {\n  const usedObjects = /* @__PURE__ */ new Set();\n  let serialized = false;\n  transaction.addSerializationPlugin(async (blockData, _options, next) => {\n    await next();\n    if (serialized) {\n      return;\n    }\n    serialized = true;\n    blockData.inputs.forEach((input) => {\n      if (input.Object?.ImmOrOwnedObject?.objectId) {\n        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n      } else if (input.Object?.Receiving?.objectId) {\n        usedObjects.add(input.Object.Receiving.objectId);\n      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {\n        usedObjects.add(input.UnresolvedObject.objectId);\n      }\n    });\n  });\n  await transaction.prepareForSerialization({ client: __privateGet(this, _client) });\n  return usedObjects;\n};\nexecute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {\n  let gasCoin;\n  try {\n    transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());\n    await __privateGet(this, _buildQueue).runTask(async () => {\n      const data = transaction.getData();\n      if (!data.gasData.price) {\n        transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));\n      }\n      transaction.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));\n      await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);\n      gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);\n      __privateWrapper(this, _pendingTransactions)._++;\n      transaction.setGasPayment([\n        {\n          objectId: gasCoin.id,\n          version: gasCoin.version,\n          digest: gasCoin.digest\n        }\n      ]);\n      await __privateGet(this, _cache).buildTransaction({ transaction, onlyTransactionKind: true });\n    });\n    const bytes = await transaction.build({ client: __privateGet(this, _client) });\n    const { signature } = await __privateGet(this, _signer).signTransaction(bytes);\n    const results = await __privateGet(this, _cache).executeTransaction({\n      transaction: bytes,\n      signature: [signature, ...additionalSignatures],\n      options: {\n        ...options,\n        showEffects: true\n      }\n    });\n    const effectsBytes = Uint8Array.from(results.rawEffects);\n    const effects = bcs.TransactionEffects.parse(effectsBytes);\n    const gasResult = getGasCoinFromEffects(effects);\n    const gasUsed = effects.V2?.gasUsed;\n    if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {\n      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);\n      const remainingBalance = gasCoin.balance - totalUsed;\n      let usesGasCoin = false;\n      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n        if (arg.$kind === \"GasCoin\") {\n          usesGasCoin = true;\n        }\n        return arg;\n      });\n      if (!usesGasCoin && remainingBalance >= __privateGet(this, _minimumCoinBalance)) {\n        __privateGet(this, _coinPool).push({\n          id: gasResult.ref.objectId,\n          version: gasResult.ref.version,\n          digest: gasResult.ref.digest,\n          balance: remainingBalance\n        });\n      } else {\n        if (!__privateGet(this, _sourceCoins)) {\n          __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());\n        }\n        __privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);\n      }\n    }\n    __privateSet(this, _lastDigest, results.digest);\n    return {\n      digest: results.digest,\n      effects: toBase64(effectsBytes),\n      data: results\n    };\n  } catch (error) {\n    if (gasCoin) {\n      if (!__privateGet(this, _sourceCoins)) {\n        __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());\n      }\n      __privateGet(this, _sourceCoins).set(gasCoin.id, null);\n    }\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {\n      await Promise.all([\n        __privateGet(this, _cache).cache.deleteObjects([...usedObjects]),\n        __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)\n      ]);\n    });\n    throw error;\n  } finally {\n    usedObjects.forEach((objectId) => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue && queue.length > 0) {\n        queue.shift()();\n      } else if (queue) {\n        __privateGet(this, _objectIdQueues).delete(objectId);\n      }\n    });\n    __privateWrapper(this, _pendingTransactions)._--;\n  }\n};\nupdateCache_fn = async function(fn) {\n  if (__privateGet(this, _cacheLock)) {\n    await __privateGet(this, _cacheLock);\n  }\n  __privateSet(this, _cacheLock, fn?.().then(\n    () => {\n      __privateSet(this, _cacheLock, null);\n    },\n    () => {\n    }\n  ) ?? null);\n};\nwaitForLastDigest_fn = async function() {\n  const digest = __privateGet(this, _lastDigest);\n  if (digest) {\n    __privateSet(this, _lastDigest, null);\n    await __privateGet(this, _client).waitForTransaction({ digest });\n  }\n};\ngetGasCoin_fn = async function() {\n  if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _pendingTransactions) <= __privateGet(this, _maxPoolSize)) {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);\n  }\n  if (__privateGet(this, _coinPool).length === 0) {\n    throw new Error(\"No coins available\");\n  }\n  const coin = __privateGet(this, _coinPool).shift();\n  return coin;\n};\ngetGasPrice_fn = async function() {\n  const remaining = __privateGet(this, _gasPrice) ? __privateGet(this, _gasPrice).expiration - __privateGet(this, _epochBoundaryWindow) - Date.now() : 0;\n  if (remaining > 0) {\n    return __privateGet(this, _gasPrice).price;\n  }\n  if (__privateGet(this, _gasPrice)) {\n    const timeToNextEpoch = Math.max(\n      __privateGet(this, _gasPrice).expiration + __privateGet(this, _epochBoundaryWindow) - Date.now(),\n      1e3\n    );\n    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n  }\n  const state = await __privateGet(this, _client).getLatestSuiSystemState();\n  __privateSet(this, _gasPrice, {\n    price: BigInt(state.referenceGasPrice),\n    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)\n  });\n  return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);\n};\nrefillCoinPool_fn = async function() {\n  const batchSize = Math.min(\n    __privateGet(this, _coinBatchSize),\n    __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _pendingTransactions)) + 1\n  );\n  if (batchSize === 0) {\n    return;\n  }\n  const txb = new Transaction();\n  const address = __privateGet(this, _signer).toSuiAddress();\n  txb.setSender(address);\n  if (__privateGet(this, _sourceCoins)) {\n    const refs = [];\n    const ids = [];\n    for (const [id, ref] of __privateGet(this, _sourceCoins)) {\n      if (ref) {\n        refs.push(ref);\n      } else {\n        ids.push(id);\n      }\n    }\n    if (ids.length > 0) {\n      const coins = await __privateGet(this, _client).multiGetObjects({\n        ids\n      });\n      refs.push(\n        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({\n          objectId: data.objectId,\n          version: data.version,\n          digest: data.digest\n        }))\n      );\n    }\n    txb.setGasPayment(refs);\n    __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());\n  }\n  const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));\n  const results = txb.splitCoins(txb.gas, amounts);\n  const coinResults = [];\n  for (let i = 0; i < amounts.length; i++) {\n    coinResults.push(results[i]);\n  }\n  txb.transferObjects(coinResults, address);\n  await this.waitForLastTransaction();\n  const result = await __privateGet(this, _client).signAndExecuteTransaction({\n    transaction: txb,\n    signer: __privateGet(this, _signer),\n    options: {\n      showRawEffects: true\n    }\n  });\n  const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));\n  effects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n      return;\n    }\n    __privateGet(this, _coinPool).push({\n      id,\n      version: effects.V2.lamportVersion,\n      digest: outputState.ObjectWrite[0],\n      balance: BigInt(__privateGet(this, _initialCoinBalance))\n    });\n  });\n  if (!__privateGet(this, _sourceCoins)) {\n    __privateSet(this, _sourceCoins, /* @__PURE__ */ new Map());\n  }\n  const gasObject = getGasCoinFromEffects(effects).ref;\n  __privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);\n  await __privateGet(this, _client).waitForTransaction({ digest: result.digest });\n};\nexport {\n  ParallelTransactionExecutor\n};\n\n", "import { bigint, object, parse, string } from \"valibot\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { normalizeStructTag } from \"../../utils/sui-types.js\";\nimport { Commands } from \"../Commands.js\";\nimport { Inputs } from \"../Inputs.js\";\nimport { getClient } from \"../resolve.js\";\nconst COIN_WITH_BALANCE = \"CoinWithBalance\";\nconst SUI_TYPE = normalizeStructTag(\"0x2::sui::SUI\");\nfunction coinWithBalance({\n  type = SUI_TYPE,\n  balance,\n  useGasCoin = true\n}) {\n  let coinResult = null;\n  return (tx) => {\n    if (coinResult) {\n      return coinResult;\n    }\n    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n    const coinType = type === \"gas\" ? type : normalizeStructTag(type);\n    coinResult = tx.add(\n      Commands.Intent({\n        name: COIN_WITH_BALANCE,\n        inputs: {},\n        data: {\n          type: coinType === SUI_TYPE && useGasCoin ? \"gas\" : coinType,\n          balance: BigInt(balance)\n        }\n      })\n    );\n    return coinResult;\n  };\n}\nconst CoinWithBalanceData = object({\n  type: string(),\n  balance: bigint()\n});\nasync function resolveCoinBalance(transactionData, buildOptions, next) {\n  const coinTypes = /* @__PURE__ */ new Set();\n  const totalByType = /* @__PURE__ */ new Map();\n  if (!transactionData.sender) {\n    throw new Error(\"Sender must be set to resolve CoinWithBalance\");\n  }\n  for (const command of transactionData.commands) {\n    if (command.$kind === \"$Intent\" && command.$Intent.name === COIN_WITH_BALANCE) {\n      const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n      if (type !== \"gas\" && balance > 0n) {\n        coinTypes.add(type);\n      }\n      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n    }\n  }\n  const usedIds = /* @__PURE__ */ new Set();\n  for (const input of transactionData.inputs) {\n    if (input.Object?.ImmOrOwnedObject) {\n      usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n    }\n    if (input.UnresolvedObject?.objectId) {\n      usedIds.add(input.UnresolvedObject.objectId);\n    }\n  }\n  const coinsByType = /* @__PURE__ */ new Map();\n  const client = getSuiClient(buildOptions);\n  await Promise.all(\n    [...coinTypes].map(async (coinType) => {\n      coinsByType.set(\n        coinType,\n        await getCoinsOfType({\n          coinType,\n          balance: totalByType.get(coinType),\n          client,\n          owner: transactionData.sender,\n          usedIds\n        })\n      );\n    })\n  );\n  const mergedCoins = /* @__PURE__ */ new Map();\n  mergedCoins.set(\"gas\", { $kind: \"GasCoin\", GasCoin: true });\n  for (const [index, transaction] of transactionData.commands.entries()) {\n    if (transaction.$kind !== \"$Intent\" || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n      continue;\n    }\n    const { type, balance } = transaction.$Intent.data;\n    if (balance === 0n && type !== \"gas\") {\n      transactionData.replaceCommand(\n        index,\n        Commands.MoveCall({ target: \"0x2::coin::zero\", typeArguments: [type] })\n      );\n      continue;\n    }\n    const commands = [];\n    if (!mergedCoins.has(type)) {\n      const [first, ...rest] = coinsByType.get(type).map(\n        (coin) => transactionData.addInput(\n          \"object\",\n          Inputs.ObjectRef({\n            objectId: coin.coinObjectId,\n            digest: coin.digest,\n            version: coin.version\n          })\n        )\n      );\n      if (rest.length > 0) {\n        commands.push(Commands.MergeCoins(first, rest));\n      }\n      mergedCoins.set(type, first);\n    }\n    commands.push(\n      Commands.SplitCoins(mergedCoins.get(type), [\n        transactionData.addInput(\"pure\", Inputs.Pure(bcs.u64().serialize(balance)))\n      ])\n    );\n    transactionData.replaceCommand(index, commands);\n    transactionData.mapArguments((arg) => {\n      if (arg.$kind === \"Result\" && arg.Result === index) {\n        return {\n          $kind: \"NestedResult\",\n          NestedResult: [index + commands.length - 1, 0]\n        };\n      }\n      return arg;\n    });\n  }\n  return next();\n}\nasync function getCoinsOfType({\n  coinType,\n  balance,\n  client,\n  owner,\n  usedIds\n}) {\n  let remainingBalance = balance;\n  const coins = [];\n  return loadMoreCoins();\n  async function loadMoreCoins(cursor = null) {\n    const { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n    for (const coin of sortedCoins) {\n      if (usedIds.has(coin.coinObjectId)) {\n        continue;\n      }\n      const coinBalance = BigInt(coin.balance);\n      coins.push(coin);\n      remainingBalance -= coinBalance;\n      if (remainingBalance <= 0) {\n        return coins;\n      }\n    }\n    if (hasNextPage) {\n      return loadMoreCoins(nextCursor);\n    }\n    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n  }\n}\nfunction getSuiClient(options) {\n  const client = getClient(options);\n  if (!client.jsonRpc) {\n    throw new Error(`CoinWithBalance intent currently only works with SuiClient`);\n  }\n  return client;\n}\nexport {\n  coinWithBalance,\n  getSuiClient\n};\n\n", "import { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nconst Arguments = {\n  pure: createPure((value) => (tx) => tx.pure(value)),\n  object: createObjectMethods((value) => (tx) => tx.object(value)),\n  sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),\n  objectRef: (...args) => (tx) => tx.objectRef(...args),\n  receivingRef: (...args) => (tx) => tx.receivingRef(...args)\n};\nexport {\n  Arguments\n};\n\n", "import { bcs } from \"@mysten/sui/bcs\";\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { fromBase64, toBase64 } from \"@mysten/sui/utils\";\nasync function signAndExecuteTransaction(wallet, input) {\n  if (wallet.features[\"sui:signAndExecuteTransaction\"]) {\n    return wallet.features[\"sui:signAndExecuteTransaction\"].signAndExecuteTransaction(input);\n  }\n  if (!wallet.features[\"sui:signAndExecuteTransactionBlock\"]) {\n    throw new Error(\n      `Provided wallet (${wallet.name}) does not support the signAndExecuteTransaction feature.`\n    );\n  }\n  const { signAndExecuteTransactionBlock } = wallet.features[\"sui:signAndExecuteTransactionBlock\"];\n  const transactionBlock = Transaction.from(await input.transaction.toJSON());\n  const { digest, rawEffects, rawTransaction } = await signAndExecuteTransactionBlock({\n    account: input.account,\n    chain: input.chain,\n    transactionBlock,\n    options: {\n      showRawEffects: true,\n      showRawInput: true\n    }\n  });\n  const [\n    {\n      txSignatures: [signature],\n      intentMessage: { value: bcsTransaction }\n    }\n  ] = bcs.SenderSignedData.parse(fromBase64(rawTransaction));\n  const bytes = bcs.TransactionData.serialize(bcsTransaction).toBase64();\n  return {\n    digest,\n    signature,\n    bytes,\n    effects: toBase64(new Uint8Array(rawEffects))\n  };\n}\nasync function signTransaction(wallet, input) {\n  if (wallet.features[\"sui:signTransaction\"]) {\n    return wallet.features[\"sui:signTransaction\"].signTransaction(input);\n  }\n  if (!wallet.features[\"sui:signTransactionBlock\"]) {\n    throw new Error(\n      `Provided wallet (${wallet.name}) does not support the signTransaction feature.`\n    );\n  }\n  const { signTransactionBlock } = wallet.features[\"sui:signTransactionBlock\"];\n  const transaction = Transaction.from(await input.transaction.toJSON());\n  const { transactionBlockBytes, signature } = await signTransactionBlock({\n    transactionBlock: transaction,\n    account: input.account,\n    chain: input.chain\n  });\n  return { bytes: transactionBlockBytes, signature };\n}\nexport {\n  signAndExecuteTransaction,\n  signTransaction\n};\n\n", "const SuiSignMessage = \"sui:signMessage\";\nexport {\n  SuiSignMessage\n};\n\n", "const SuiSignTransactionBlock = \"sui:signTransactionBlock\";\nexport {\n  SuiSignTransactionBlock\n};\n\n", "const SuiSignTransaction = \"sui:signTransaction\";\nexport {\n  SuiSignTransaction\n};\n\n", "const SuiSignAndExecuteTransactionBlock = \"sui:signAndExecuteTransactionBlock\";\nexport {\n  SuiSignAndExecuteTransactionBlock\n};\n\n", "const SuiSignAndExecuteTransaction = \"sui:signAndExecuteTransaction\";\nexport {\n  SuiSignAndExecuteTransaction\n};\n\n", "const SuiSignPersonalMessage = \"sui:signPersonalMessage\";\nexport {\n  SuiSignPersonalMessage\n};\n\n", "const SuiReportTransactionEffects = \"sui:reportTransactionEffects\";\nexport {\n  SuiReportTransactionEffects\n};\n\n", "const SuiGetCapabilities = \"sui:getCapabilities\";\nexport {\n  SuiGetCapabilities\n};\n\n", "import { StandardConnect, StandardEvents } from \"@wallet-standard/core\";\nconst REQUIRED_FEATURES = [StandardConnect, StandardEvents];\nfunction isWalletWithRequiredFeatureSet(wallet, additionalFeatures = []) {\n  return [...REQUIRED_FEATURES, ...additionalFeatures].every(\n    (feature) => feature in wallet.features\n  );\n}\nexport {\n  isWalletWithRequiredFeatureSet\n};\n\n", "const SUI_DEVNET_CHAIN = \"sui:devnet\";\nconst SUI_TESTNET_CHAIN = \"sui:testnet\";\nconst SUI_LOCALNET_CHAIN = \"sui:localnet\";\nconst SUI_MAINNET_CHAIN = \"sui:mainnet\";\nconst SUI_CHAINS = [\n  SUI_DEVNET_CHAIN,\n  SUI_TESTNET_CHAIN,\n  SUI_LOCALNET_CHAIN,\n  SUI_MAINNET_CHAIN\n];\nfunction isSuiChain(chain) {\n  return SUI_CHAINS.includes(chain);\n}\nexport {\n  SUI_CHAINS,\n  SUI_DEVNET_CHAIN,\n  SUI_LOCALNET_CHAIN,\n  SUI_MAINNET_CHAIN,\n  SUI_TESTNET_CHAIN,\n  isSuiChain\n};\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAI,yBAAkE,SAAU,UAAU,OAAO,MAAM,GAAG;AACtG,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,0EAA0E;AACjL,SAAO,SAAS,MAAM,IAAI,SAAS,MAAM,EAAE,KAAK,QAAQ,IAAI,IAAI,EAAE,QAAQ,MAAM,IAAI,QAAQ;AAChG;AACA,IAAI,yBAAkE,SAAU,UAAU,OAAO,OAAO,MAAM,GAAG;AAC7G,MAAI,SAAS,IAAK,OAAM,IAAI,UAAU,gCAAgC;AACtE,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,yEAAyE;AAChL,SAAQ,SAAS,MAAM,EAAE,KAAK,UAAU,KAAK,IAAI,IAAI,EAAE,QAAQ,QAAQ,MAAM,IAAI,UAAU,KAAK,GAAI;AACxG;AACA,IAAI;AACJ,IAAI,UAAU;AACd,IAAM,uBAAuB,oBAAI,IAAI;AACrC,SAAS,oBAAoB,QAAQ;AACjC,uBAAqB;AACrB,uBAAqB,IAAI,MAAM;AACnC;AACA,SAAS,uBAAuB,QAAQ;AACpC,uBAAqB;AACrB,uBAAqB,OAAO,MAAM;AACtC;AACA,IAAM,YAAY,CAAC;AAoBZ,SAAS,aAAa;AACzB,MAAI;AACA,WAAO;AACX,YAAU,OAAO,OAAO,EAAE,UAAU,KAAK,GAAG,CAAC;AAC7C,MAAI,OAAO,WAAW;AAClB,WAAO;AACX,QAAM,MAAM,OAAO,OAAO,EAAE,SAAS,CAAC;AACtC,MAAI;AACA,WAAO,iBAAiB,mCAAmC,CAAC,EAAE,QAAQ,SAAS,MAAM,SAAS,GAAG,CAAC;AAAA,EACtG,SACO,OAAO;AACV,YAAQ,MAAM,uEAAuE,KAAK;AAAA,EAC9F;AACA,MAAI;AACA,WAAO,cAAc,IAAI,cAAc,GAAG,CAAC;AAAA,EAC/C,SACO,OAAO;AACV,YAAQ,MAAM,6DAA6D,KAAK;AAAA,EACpF;AACA,SAAO;AACX;AACA,SAAS,YAAYA,UAAS;AAI1B,EAAAA,WAAUA,SAAQ,OAAO,CAAC,WAAW,CAAC,qBAAqB,IAAI,MAAM,CAAC;AAGtE,MAAI,CAACA,SAAQ;AACT,WAAO,MAAM;AAAA,IAAE;AACnB,EAAAA,SAAQ,QAAQ,CAAC,WAAW,oBAAoB,MAAM,CAAC;AACvD,YAAU,UAAU,GAAG,QAAQ,CAAC,aAAa,MAAM,MAAM,SAAS,GAAGA,QAAO,CAAC,CAAC;AAE9E,SAAO,SAAS,aAAa;AACzB,IAAAA,SAAQ,QAAQ,CAAC,WAAW,uBAAuB,MAAM,CAAC;AAC1D,cAAU,YAAY,GAAG,QAAQ,CAAC,aAAa,MAAM,MAAM,SAAS,GAAGA,QAAO,CAAC,CAAC;AAAA,EACpF;AACJ;AACA,IAAI;AACJ,SAAS,MAAM;AACX,MAAI,CAAC,oBAAoB;AACrB,yBAAqB,CAAC,GAAG,oBAAoB;AAAA,EACjD;AACA,SAAO;AACX;AACA,SAAS,GAAG,OAAO,UAAU;AACzB,YAAU,KAAK,GAAG,KAAK,QAAQ,MAAM,UAAU,KAAK,IAAI,CAAC,QAAQ;AAEjE,SAAO,SAAS,MAAM;AAClB,cAAU,KAAK,IAAI,UAAU,KAAK,GAAG,OAAO,CAAC,qBAAqB,aAAa,gBAAgB;AAAA,EACnG;AACJ;AACA,SAAS,MAAM,UAAU;AACrB,MAAI;AACA,aAAS;AAAA,EACb,SACO,OAAO;AACV,YAAQ,MAAM,KAAK;AAAA,EACvB;AACJ;AACA,IAAM,gBAAN,cAA4B,MAAM;AAAA,EAC9B,IAAI,SAAS;AACT,WAAO,uBAAuB,MAAM,uBAAuB,GAAG;AAAA,EAClE;AAAA,EACA,IAAI,OAAO;AACP,WAAO;AAAA,EACX;AAAA,EACA,YAAY,KAAK;AACb,UAAM,6BAA6B;AAAA,MAC/B,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,UAAU;AAAA,IACd,CAAC;AACD,0BAAsB,IAAI,MAAM,MAAM;AACtC,2BAAuB,MAAM,uBAAuB,KAAK,GAAG;AAAA,EAChE;AAAA;AAAA,EAEA,iBAAiB;AACb,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAAA;AAAA,EAEA,2BAA2B;AACvB,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AAAA;AAAA,EAEA,kBAAkB;AACd,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AACJ;AACA,wBAAwB,oBAAI,QAAQ;AAM7B,SAAS,wBAAwB;AACpC,MAAI;AACA,WAAO;AACX,YAAU,WAAW;AACrB,MAAI,OAAO,WAAW;AAClB,WAAO;AACX,QAAM,YAAY,OAAO,UAAU,WAAW,CAAC;AAC/C,MAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC3B,YAAQ,MAAM,0CAA0C;AACxD,WAAO;AAAA,EACX;AACA,QAAM,EAAE,UAAAC,UAAS,IAAI;AACrB,QAAM,OAAO,IAAIC,eAAcA,WAAU,QAAQ,CAAC,aAAa,MAAM,MAAM,SAAS,EAAE,UAAAD,UAAS,CAAC,CAAC,CAAC;AAClG,MAAI;AACA,WAAO,eAAe,OAAO,WAAW,WAAW;AAAA,MAC/C,OAAO,OAAO,OAAO,EAAE,KAAK,CAAC;AAAA,IACjC,CAAC;AAAA,EACL,SACO,OAAO;AACV,YAAQ,MAAM,2CAA2C;AACzD,WAAO;AAAA,EACX;AACA,OAAK,GAAG,SAAS;AACjB,SAAO;AACX;;;ACtIO,IAAM,oDAAoD;AAC1D,IAAM,4DAA4D;AAGlE,IAAM,gDAAgD;AAGtD,IAAM,oEAAoE;AAC1E,IAAM,wEAAwE;AAC9E,IAAM,gEAAgE;;;AC5BtE,IAAM,8BAA8B;AAAA,EACvC,CAAC,iEAAiE,GAAG;AAAA,EACrE,CAAC,qEAAqE,GAAG;AAAA,EACzE,CAAC,6DAA6D,GAAG;AAAA,EACjE,CAAC,yDAAyD,GAAG;AAAA,EAC7D,CAAC,iDAAiD,GAAG;AAAA,EAErD,CAAC,6CAA6C,GAAG;AACrD;;;ACdA,IAAI;AAAA,CACH,SAAUE,YAAW;AAClB,EAAAA,WAAUA,WAAU,gBAAgB,IAAI,CAAC,IAAI;AAC7C,EAAAA,WAAUA,WAAU,MAAM,IAAI,CAAC,IAAI;AACnC,EAAAA,WAAUA,WAAU,UAAU,IAAI,CAAC,IAAI;AAC3C,GAAG,cAAc,YAAY,CAAC,EAAE;AAChC,IAAM,cAAc;AACpB,IAAM,OAAO;AACN,SAAS,6BAA6B,MAAM,UAAU,CAAC,GAAG;AAC7D,QAAM,sBAAsB,4BAA4B,IAAI;AAC5D,MAAI,oBAAoB,WAAW,GAAG;AAClC,WAAO;AAAA,EACX;AACA,MAAI;AACJ,WAAS,gBAAgB,UAAU;AAC/B,QAAI,MAAM,IAAI,MAAM,UAAU,UAAU;AACpC,YAAM,eAAe,oBAAoB,MAAM,MAAM,WAAW,IAAI,GAAG,QAAQ;AAC/E,gBAAU,KAAK,gBAAgB,UAAU,GAAG,QAAQ,YAAY,CAAC,KAAK,IAAI,YAAY,EAAE;AAAA,IAC5F,WACS,MAAM,IAAI,MAAM,UAAU,MAAM;AACrC,gBAAU,KAAK,oBAAoB,MAAM,MAAM,WAAW,GAAG,QAAQ,CAAC;AAAA,IAC1E;AAAA,EACJ;AACA,QAAM,YAAY,CAAC;AACnB,sBAAoB,MAAM,EAAE,EAAE,QAAQ,CAAC,MAAM,OAAO;AAChD,QAAI,OAAO,GAAG;AACV,cAAQ;AAAA,QACJ,CAAC,WAAW,GAAG;AAAA,QACf,CAAC,IAAI,GAAG,oBAAoB,CAAC,MAAM,OAC7B,UAAU,iBACV,oBAAoB,CAAC,MAAM,MACvB,UAAU,WACV,UAAU;AAAA,MACxB;AACA;AAAA,IACJ;AACA,QAAI;AACJ,YAAQ,MAAM,IAAI,GAAG;AAAA,MACjB,KAAK,UAAU;AACX,oBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,KAAK;AACxD;AAAA,MACJ,KAAK,UAAU;AACX,YAAI,SAAS,MAAM;AACf,sBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,eAAe;AAAA,QACtE,WACS,SAAS,KAAK;AACnB,sBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,SAAS;AAAA,QAChE;AACA;AAAA,MACJ,KAAK,UAAU;AACX,YAAI,SAAS,MAAM;AACf,sBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,eAAe;AAAA,QACtE,WACS,SAAS,KAAK;AACnB,sBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,SAAS;AAAA,QAChE,WACS,CAAC,KAAK,MAAM,IAAI,GAAG;AACxB,sBAAY,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,KAAK;AAAA,QAC5D;AACA;AAAA,IACR;AACA,QAAI,WAAW;AACX,UAAI,UAAU,WAAW;AACrB,wBAAgB,EAAE;AAAA,MACtB;AACA,cAAQ;AAAA,IACZ;AAAA,EACJ,CAAC;AACD,kBAAgB;AAChB,SAAO,UAAU,KAAK,EAAE;AAC5B;AACO,SAAS,gBAAgB,MAAM,UAAU,CAAC,GAAG;AAChD,MAAI,MAAuC;AACvC,WAAO,6BAA6B,MAAM,OAAO;AAAA,EACrD,OACK;AACD,QAAI,wBAAwB,0BAA0B,IAAI,0EAA0E,IAAI;AACxI,QAAI,OAAO,KAAK,OAAO,EAAE,QAAQ;AAM7B,+BAAyB,KAAK,oBAAoB,OAAO,CAAC;AAAA,IAC9D;AACA,WAAO,GAAG,qBAAqB;AAAA,EACnC;AACJ;;;ACxFO,SAAS,sBAAsB,GAAG,MAAM;AAC3C,QAAMC,yBAAwB,aAAa,SAAS,EAAE,SAAS;AAC/D,MAAIA,wBAAuB;AACvB,QAAI,SAAS,QAAW;AACpB,aAAO,EAAE,QAAQ,WAAW;AAAA,IAChC;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACO,IAAM,sBAAN,cAAkC,MAAM;AAAA,EAC3C,eAAe,CAAC,MAAM,sBAAsB,GAAG;AAC3C,QAAI;AACJ,QAAI;AACJ,QAAI,wBAAwB;AAExB,YAAkC,6BAA1B,QAjBpB,IAiB8C,IAAhB,wBAAgB,IAAhB,CAAV;AACR,UAAI,OAAO;AACP,uBAAe,EAAE,MAAM;AAAA,MAC3B;AACA,UAAI,OAAO,KAAK,WAAW,EAAE,SAAS,GAAG;AACrC,kBAAU;AAAA,MACd;AAAA,IACJ;AACA,UAAM,UAAU,gBAAgB,MAAM,OAAO;AAC7C,UAAM,SAAS,YAAY;AAC3B,SAAK,UAAU;AAAA,MACX,QAAQ;AAAA,OACL;AAIP,SAAK,OAAO;AAAA,EAChB;AACJ;;;ACnCO,SAAS,yBAAyB,MAAM;AAC3C,MAAI,uBAAuB,SAAS,OAAO,MAAM,sBAAsB,YAAY;AAC/E,UAAM,kBAAkB,GAAG,IAAI;AAAA,EACnC;AACJ;;;ACHO,IAAM,kBAAkB;AAMxB,IAAM,UAAU;;;ACNhB,IAAM,qBAAqB;AAM3B,IAAM,aAAa;;;ACNnB,IAAM,iBAAiB;AAMvB,IAAM,SAAS;;;ACPtB,IAAIC,0BAAkE,SAAU,UAAU,OAAO,MAAM,GAAG;AACtG,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,0EAA0E;AACjL,SAAO,SAAS,MAAM,IAAI,SAAS,MAAM,EAAE,KAAK,QAAQ,IAAI,IAAI,EAAE,QAAQ,MAAM,IAAI,QAAQ;AAChG;AACA,IAAIC,0BAAkE,SAAU,UAAU,OAAO,OAAO,MAAM,GAAG;AAC7G,MAAI,SAAS,IAAK,OAAM,IAAI,UAAU,gCAAgC;AACtE,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,yEAAyE;AAChL,SAAQ,SAAS,MAAM,EAAE,KAAK,UAAU,KAAK,IAAI,IAAI,EAAE,QAAQ,QAAQ,MAAM,IAAI,UAAU,KAAK,GAAI;AACxG;AACA,IAAI;AAiBG,SAAS,eAAe,QAAQ;AACnC,QAAM,WAAW,CAAC,EAAE,UAAAC,UAAS,MAAMA,UAAS,MAAM;AAClD,MAAI;AACA,WAAO,cAAc,IAAI,oBAAoB,QAAQ,CAAC;AAAA,EAC1D,SACO,OAAO;AACV,YAAQ,MAAM,mEAAmE,KAAK;AAAA,EAC1F;AACA,MAAI;AACA,WAAO,iBAAiB,6BAA6B,CAAC,EAAE,QAAQ,IAAI,MAAM,SAAS,GAAG,CAAC;AAAA,EAC3F,SACO,OAAO;AACV,YAAQ,MAAM,iEAAiE,KAAK;AAAA,EACxF;AACJ;AACA,IAAM,sBAAN,cAAkC,MAAM;AAAA,EACpC,IAAI,SAAS;AACT,WAAOF,wBAAuB,MAAM,6BAA6B,GAAG;AAAA,EACxE;AAAA,EACA,IAAI,OAAO;AACP,WAAO;AAAA,EACX;AAAA,EACA,YAAY,UAAU;AAClB,UAAM,mCAAmC;AAAA,MACrC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,UAAU;AAAA,IACd,CAAC;AACD,gCAA4B,IAAI,MAAM,MAAM;AAC5C,IAAAC,wBAAuB,MAAM,6BAA6B,UAAU,GAAG;AAAA,EAC3E;AAAA;AAAA,EAEA,iBAAiB;AACb,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACrD;AAAA;AAAA,EAEA,2BAA2B;AACvB,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AAAA;AAAA,EAEA,kBAAkB;AACd,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AACJ;AACA,8BAA8B,oBAAI,QAAQ;AAMnC,SAAS,0BAA0B,QAAQ;AAC9C,MAAI;AACJ,iBAAe,MAAM;AACrB,MAAI;AACA,MAAE,KAAK,OAAO,WAAW,YAAY,GAAG,UAAU,CAAC,IAAI,KAAK,CAAC,EAAE,UAAAC,UAAS,MAAMA,UAAS,MAAM,CAAC;AAAA,EAClG,SACO,OAAO;AACV,YAAQ,MAAM,kDAAkD,KAAK;AAAA,EACzE;AACJ;;;ACvFA,IAAIC,0BAAkE,SAAU,UAAU,OAAO,MAAM,GAAG;AACtG,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,0EAA0E;AACjL,SAAO,SAAS,MAAM,IAAI,SAAS,MAAM,EAAE,KAAK,QAAQ,IAAI,IAAI,EAAE,QAAQ,MAAM,IAAI,QAAQ;AAChG;AACA,IAAIC,0BAAkE,SAAU,UAAU,OAAO,OAAO,MAAM,GAAG;AAC7G,MAAI,SAAS,IAAK,OAAM,IAAI,UAAU,gCAAgC;AACtE,MAAI,SAAS,OAAO,CAAC,EAAG,OAAM,IAAI,UAAU,+CAA+C;AAC3F,MAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,yEAAyE;AAChL,SAAQ,SAAS,MAAM,EAAE,KAAK,UAAU,KAAK,IAAI,IAAI,EAAE,QAAQ,QAAQ,MAAM,IAAI,UAAU,KAAK,GAAI;AACxG;AACA,IAAI;AAAJ,IAAoC;AAApC,IAAsE;AAAtE,IAAqG;AAArG,IAAsI;AAAtI,IAAoK;AAa7J,IAAM,wBAAN,MAAM,uBAAsB;AAAA;AAAA,EAE/B,IAAI,UAAU;AACV,WAAOD,wBAAuB,MAAM,gCAAgC,GAAG;AAAA,EAC3E;AAAA;AAAA,EAEA,IAAI,YAAY;AACZ,WAAOA,wBAAuB,MAAM,kCAAkC,GAAG,EAAE,MAAM;AAAA,EACrF;AAAA;AAAA,EAEA,IAAI,SAAS;AACT,WAAOA,wBAAuB,MAAM,+BAA+B,GAAG,EAAE,MAAM;AAAA,EAClF;AAAA;AAAA,EAEA,IAAI,WAAW;AACX,WAAOA,wBAAuB,MAAM,iCAAiC,GAAG,EAAE,MAAM;AAAA,EACpF;AAAA;AAAA,EAEA,IAAI,QAAQ;AACR,WAAOA,wBAAuB,MAAM,8BAA8B,GAAG;AAAA,EACzE;AAAA;AAAA,EAEA,IAAI,OAAO;AACP,WAAOA,wBAAuB,MAAM,6BAA6B,GAAG;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,SAAS;AACjB,mCAA+B,IAAI,MAAM,MAAM;AAC/C,qCAAiC,IAAI,MAAM,MAAM;AACjD,kCAA8B,IAAI,MAAM,MAAM;AAC9C,oCAAgC,IAAI,MAAM,MAAM;AAChD,iCAA6B,IAAI,MAAM,MAAM;AAC7C,gCAA4B,IAAI,MAAM,MAAM;AAC5C,QAAI,eAAe,wBAAuB;AACtC,aAAO,OAAO,IAAI;AAAA,IACtB;AACA,IAAAC,wBAAuB,MAAM,gCAAgC,QAAQ,SAAS,GAAG;AACjF,IAAAA,wBAAuB,MAAM,kCAAkC,QAAQ,UAAU,MAAM,GAAG,GAAG;AAC7F,IAAAA,wBAAuB,MAAM,+BAA+B,QAAQ,OAAO,MAAM,GAAG,GAAG;AACvF,IAAAA,wBAAuB,MAAM,iCAAiC,QAAQ,SAAS,MAAM,GAAG,GAAG;AAC3F,IAAAA,wBAAuB,MAAM,8BAA8B,QAAQ,OAAO,GAAG;AAC7E,IAAAA,wBAAuB,MAAM,6BAA6B,QAAQ,MAAM,GAAG;AAAA,EAC/E;AACJ;AACA,iCAAiC,oBAAI,QAAQ,GAAG,mCAAmC,oBAAI,QAAQ,GAAG,gCAAgC,oBAAI,QAAQ,GAAG,kCAAkC,oBAAI,QAAQ,GAAG,+BAA+B,oBAAI,QAAQ,GAAG,8BAA8B,oBAAI,QAAQ;AAWnR,SAAS,YAAY,GAAG,GAAG;AAC9B,MAAI,MAAM;AACN,WAAO;AACX,QAAM,SAAS,EAAE;AACjB,MAAI,WAAW,EAAE;AACb,WAAO;AACX,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,QAAI,EAAE,CAAC,MAAM,EAAE,CAAC;AACZ,aAAO;AAAA,EACf;AACA,SAAO;AACX;AAWO,SAAS,WAAW,GAAG,GAAG;AAC7B,SAAO,YAAY,GAAG,CAAC;AAC3B;AAWO,SAAS,YAAY,UAAU,QAAQ;AAC1C,QAAM,SAAS,OAAO,OAAO,CAACC,SAAQC,WAAUD,UAASC,OAAM,QAAQ,MAAM,MAAM;AACnF,QAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,QAAM,IAAI,OAAO,CAAC;AAClB,aAAW,SAAS,QAAQ;AACxB,UAAM,IAAI,OAAO,MAAM,MAAM;AAAA,EACjC;AACA,SAAO;AACX;AAWO,SAAS,KAAK,WAAW,MAAM;AAClC,QAAM,SAAS,CAAC;AAChB,aAAW,OAAO,MAAM;AACpB,WAAO,GAAG,IAAI,OAAO,GAAG;AAAA,EAC5B;AACA,SAAO;AACX;AAQO,SAASC,OAAM,UAAU;AAC5B,MAAI;AACA,aAAS;AAAA,EACb,SACO,OAAO;AACV,YAAQ,MAAM,KAAK;AAAA,EACvB;AACJ;;;ACvJA,IAAI;AAAJ,IAAa;AAAb,IAAqB;AAuFrB,UAAU,oBAAI,QAAQ;AAuHtB,SAAS,oBAAI,QAAQ;AACrB,aAAa,oBAAI,QAAQ;;;AC/MzB,IAAI;AAAJ,IAAa;AAiFb,UAAU,oBAAI,QAAQ;AACtB,cAAc,oBAAI,QAAQ;;;ACnF1B,IAAI;AAAJ,IAAY;AAqBZ,SAAS,oBAAI,QAAQ;AAgCrB,UAAU,oBAAI,QAAQ;;;ACpDtB,IAAIC;AAAJ,IAAY;AAAZ,IAAqBC;AAArB,IAA6B;AAA7B,IAAgD;AAAhD,IAA+D;AA6E/DC,UAAS,oBAAI,QAAQ;AACrB,UAAU,oBAAI,QAAQ;AACtBC,UAAS,oBAAI,QAAQ;AACrB,oBAAoB,oBAAI,QAAQ;AAChC,gBAAgB,oBAAI,QAAQ;AAC5B,oBAAoB,oBAAI,QAAQ;AAChC,SAAS,sBAAsB,SAAS;AACtC,MAAI,CAAC,QAAQ,IAAI;AACf,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACA,QAAM,kBAAkB,QAAQ,GAAG,eAAe,QAAQ,GAAG,cAAc;AAC3E,MAAI,CAAC,iBAAiB;AACpB,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,QAAM,CAAC,UAAU,EAAE,YAAY,CAAC,IAAI;AACpC,MAAI,CAAC,YAAY,aAAa;AAC5B,UAAM,IAAI,MAAM,6BAA6B;AAAA,EAC/C;AACA,QAAM,CAAC,QAAQ,KAAK,IAAI,YAAY;AACpC,SAAO;AAAA,IACL,KAAK;AAAA,MACH;AAAA,MACA;AAAA,MACA,SAAS,QAAQ,GAAG;AAAA,IACtB;AAAA,IACA,OAAO,MAAM,gBAAgB,MAAM;AAAA,EACrC;AACF;;;AC/GA,IAAI,cAAc,CAAC,QAAQ;AACzB,QAAM,UAAU,GAAG;AACrB;AACA,IAAI,gBAAgB,CAAC,KAAK,QAAQ,QAAQ,OAAO,IAAI,GAAG,KAAK,YAAY,YAAY,GAAG;AACxF,IAAI,eAAe,CAAC,KAAK,QAAQ,YAAY,cAAc,KAAK,QAAQ,yBAAyB,GAAG,SAAS,OAAO,KAAK,GAAG,IAAI,OAAO,IAAI,GAAG;AAE9I,IAAI,eAAe,CAAC,KAAK,QAAQ,OAAO,YAAY,cAAc,KAAK,QAAQ,wBAAwB,GAAG,SAAS,OAAO,KAAK,KAAK,KAAK,IAAI,OAAO,IAAI,KAAK,KAAK,GAAG;AACrK,IAAI,kBAAkB,CAAC,KAAK,QAAQ,YAAY,cAAc,KAAK,QAAQ,uBAAuB,GAAG;AACrG,IAAI,mBAAmB,CAAC,KAAK,QAAQ,QAAQ,YAAY;AAAA,EACvD,IAAI,EAAE,OAAO;AACX,iBAAa,KAAK,QAAQ,OAAO,MAAM;AAAA,EACzC;AAAA,EACA,IAAI,IAAI;AACN,WAAO,aAAa,KAAK,QAAQ,MAAM;AAAA,EACzC;AACF;AACA,IAAIC;AAAJ,IAAaC;AAAb,IAAsB;AAAtB,IAAsC;AAAtC,IAA2D;AAA3D,IAAgF;AAAhF,IAAsGC;AAAtG,IAAyH;AAAzH,IAAuI;AAAvI,IAAqJ;AAArJ,IAAgKC;AAAhK,IAAwK;AAAxK,IAAyL;AAAzL,IAAsM;AAAtM,IAAqNC;AAArN,IAAkO;AAAlO,IAA8O;AAA9O,IAAoQ;AAApQ,IAA+Q;AAA/Q,IAAuT;AAAvT,IAA0U;AAA1U,IAAsV;AAAtV,IAAsW;AAAtW,IAA4X;AAA5X,IAA2Y;AAA3Y,IAA2Z;AAyF3ZC,WAAU,oBAAI,QAAQ;AACtBC,WAAU,oBAAI,QAAQ;AACtB,iBAAiB,oBAAI,QAAQ;AAC7B,sBAAsB,oBAAI,QAAQ;AAClC,sBAAsB,oBAAI,QAAQ;AAClC,uBAAuB,oBAAI,QAAQ;AACnCC,qBAAoB,oBAAI,QAAQ;AAChC,eAAe,oBAAI,QAAQ;AAC3B,eAAe,oBAAI,QAAQ;AAC3B,YAAY,oBAAI,QAAQ;AACxBC,UAAS,oBAAI,QAAQ;AACrB,kBAAkB,oBAAI,QAAQ;AAC9B,cAAc,oBAAI,QAAQ;AAC1B,gBAAgB,oBAAI,QAAQ;AAC5BC,eAAc,oBAAI,QAAQ;AAC1B,aAAa,oBAAI,QAAQ;AACzB,uBAAuB,oBAAI,QAAQ;AACnC,YAAY,oBAAI,QAAQ;AACxB,yCAAyC,oBAAI,QAAQ;AACrD,oBAAoB,eAAe,aAAa;AAC9C,QAAM,cAA8B,oBAAI,IAAI;AAC5C,MAAI,aAAa;AACjB,cAAY,uBAAuB,OAAO,WAAW,UAAU,SAAS;AACtE,UAAM,KAAK;AACX,QAAI,YAAY;AACd;AAAA,IACF;AACA,iBAAa;AACb,cAAU,OAAO,QAAQ,CAAC,UAAU;AAClC,UAAI,MAAM,QAAQ,kBAAkB,UAAU;AAC5C,oBAAY,IAAI,MAAM,OAAO,iBAAiB,QAAQ;AAAA,MACxD,WAAW,MAAM,QAAQ,WAAW,UAAU;AAC5C,oBAAY,IAAI,MAAM,OAAO,UAAU,QAAQ;AAAA,MACjD,WAAW,MAAM,kBAAkB,YAAY,CAAC,MAAM,iBAAiB,sBAAsB;AAC3F,oBAAY,IAAI,MAAM,iBAAiB,QAAQ;AAAA,MACjD;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACD,QAAM,YAAY,wBAAwB,EAAE,QAAQ,aAAa,MAAMH,QAAO,EAAE,CAAC;AACjF,SAAO;AACT;AACA,aAAa,eAAe,aAAa,aAAa,SAAS,uBAAuB,CAAC,GAAG;AACxF,MAAI;AACJ,MAAI;AACF,gBAAY,kBAAkB,aAAa,MAAMD,QAAO,EAAE,aAAa,CAAC;AACxE,UAAM,aAAa,MAAM,WAAW,EAAE,QAAQ,YAAY;AACxD,YAAM,OAAO,YAAY,QAAQ;AACjC,UAAI,CAAC,KAAK,QAAQ,OAAO;AACvB,oBAAY,YAAY,MAAM,gBAAgB,MAAM,wCAAwC,cAAc,EAAE,KAAK,IAAI,CAAC;AAAA,MACxH;AACA,kBAAY,qBAAqB,aAAa,MAAME,kBAAiB,CAAC;AACtE,YAAM,gBAAgB,MAAM,wCAAwC,cAAc,EAAE,KAAK,IAAI;AAC7F,gBAAU,MAAM,gBAAgB,MAAM,wCAAwC,aAAa,EAAE,KAAK,IAAI;AACtG,uBAAiB,MAAM,oBAAoB,EAAE;AAC7C,kBAAY,cAAc;AAAA,QACxB;AAAA,UACE,UAAU,QAAQ;AAAA,UAClB,SAAS,QAAQ;AAAA,UACjB,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF,CAAC;AACD,YAAM,aAAa,MAAMC,OAAM,EAAE,iBAAiB,EAAE,aAAa,qBAAqB,KAAK,CAAC;AAAA,IAC9F,CAAC;AACD,UAAM,QAAQ,MAAM,YAAY,MAAM,EAAE,QAAQ,aAAa,MAAMF,QAAO,EAAE,CAAC;AAC7E,UAAM,EAAE,UAAU,IAAI,MAAM,aAAa,MAAMD,QAAO,EAAE,gBAAgB,KAAK;AAC7E,UAAM,UAAU,MAAM,aAAa,MAAMG,OAAM,EAAE,mBAAmB;AAAA,MAClE,aAAa;AAAA,MACb,WAAW,CAAC,WAAW,GAAG,oBAAoB;AAAA,MAC9C,SAAS,iCACJ,UADI;AAAA,QAEP,aAAa;AAAA,MACf;AAAA,IACF,CAAC;AACD,UAAM,eAAe,WAAW,KAAK,QAAQ,UAAU;AACvD,UAAM,UAAU,OAAI,mBAAmB,MAAM,YAAY;AACzD,UAAM,YAAY,sBAAsB,OAAO;AAC/C,UAAM,UAAU,QAAQ,IAAI;AAC5B,QAAI,WAAW,WAAW,UAAU,UAAU,aAAa,MAAMH,QAAO,EAAE,aAAa,GAAG;AACxF,YAAM,YAAY,OAAO,QAAQ,eAAe,IAAI,OAAO,QAAQ,WAAW,IAAI,OAAO,QAAQ,WAAW,IAAI,OAAO,QAAQ,aAAa;AAC5I,YAAM,mBAAmB,QAAQ,UAAU;AAC3C,UAAI,cAAc;AAClB,UAAI,uBAAuB,YAAY,QAAQ,CAAC,EAAE,aAAa,CAAC,QAAQ;AACtE,YAAI,IAAI,UAAU,WAAW;AAC3B,wBAAc;AAAA,QAChB;AACA,eAAO;AAAA,MACT,CAAC;AACD,UAAI,CAAC,eAAe,oBAAoB,aAAa,MAAM,mBAAmB,GAAG;AAC/E,qBAAa,MAAM,SAAS,EAAE,KAAK;AAAA,UACjC,IAAI,UAAU,IAAI;AAAA,UAClB,SAAS,UAAU,IAAI;AAAA,UACvB,QAAQ,UAAU,IAAI;AAAA,UACtB,SAAS;AAAA,QACX,CAAC;AAAA,MACH,OAAO;AACL,YAAI,CAAC,aAAa,MAAM,YAAY,GAAG;AACrC,uBAAa,MAAM,cAA8B,oBAAI,IAAI,CAAC;AAAA,QAC5D;AACA,qBAAa,MAAM,YAAY,EAAE,IAAI,UAAU,IAAI,UAAU,UAAU,GAAG;AAAA,MAC5E;AAAA,IACF;AACA,iBAAa,MAAMI,cAAa,QAAQ,MAAM;AAC9C,WAAO;AAAA,MACL,QAAQ,QAAQ;AAAA,MAChB,SAAS,SAAS,YAAY;AAAA,MAC9B,MAAM;AAAA,IACR;AAAA,EACF,SAAS,OAAO;AACd,QAAI,SAAS;AACX,UAAI,CAAC,aAAa,MAAM,YAAY,GAAG;AACrC,qBAAa,MAAM,cAA8B,oBAAI,IAAI,CAAC;AAAA,MAC5D;AACA,mBAAa,MAAM,YAAY,EAAE,IAAI,QAAQ,IAAI,IAAI;AAAA,IACvD;AACA,UAAM,gBAAgB,MAAM,wCAAwC,cAAc,EAAE,KAAK,MAAM,YAAY;AACzG,YAAM,QAAQ,IAAI;AAAA,QAChB,aAAa,MAAMD,OAAM,EAAE,MAAM,cAAc,CAAC,GAAG,WAAW,CAAC;AAAA,QAC/D,gBAAgB,MAAM,wCAAwC,oBAAoB,EAAE,KAAK,IAAI;AAAA,MAC/F,CAAC;AAAA,IACH,CAAC;AACD,UAAM;AAAA,EACR,UAAE;AACA,gBAAY,QAAQ,CAAC,aAAa;AAChC,YAAM,QAAQ,aAAa,MAAM,eAAe,EAAE,IAAI,QAAQ;AAC9D,UAAI,SAAS,MAAM,SAAS,GAAG;AAC7B,cAAM,MAAM,EAAE;AAAA,MAChB,WAAW,OAAO;AAChB,qBAAa,MAAM,eAAe,EAAE,OAAO,QAAQ;AAAA,MACrD;AAAA,IACF,CAAC;AACD,qBAAiB,MAAM,oBAAoB,EAAE;AAAA,EAC/C;AACF;AACA,iBAAiB,eAAe,IAAI;AAClC,MAAI,aAAa,MAAM,UAAU,GAAG;AAClC,UAAM,aAAa,MAAM,UAAU;AAAA,EACrC;AACA,eAAa,MAAM,YAAY,KAAK,EAAE;AAAA,IACpC,MAAM;AACJ,mBAAa,MAAM,YAAY,IAAI;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,IACN;AAAA,EACF,KAAK,IAAI;AACX;AACA,uBAAuB,iBAAiB;AACtC,QAAM,SAAS,aAAa,MAAMC,YAAW;AAC7C,MAAI,QAAQ;AACV,iBAAa,MAAMA,cAAa,IAAI;AACpC,UAAM,aAAa,MAAMH,QAAO,EAAE,mBAAmB,EAAE,OAAO,CAAC;AAAA,EACjE;AACF;AACA,gBAAgB,iBAAiB;AAC/B,MAAI,aAAa,MAAM,SAAS,EAAE,WAAW,KAAK,aAAa,MAAM,oBAAoB,KAAK,aAAa,MAAM,YAAY,GAAG;AAC9H,UAAM,gBAAgB,MAAM,wCAAwC,iBAAiB,EAAE,KAAK,IAAI;AAAA,EAClG;AACA,MAAI,aAAa,MAAM,SAAS,EAAE,WAAW,GAAG;AAC9C,UAAM,IAAI,MAAM,oBAAoB;AAAA,EACtC;AACA,QAAM,OAAO,aAAa,MAAM,SAAS,EAAE,MAAM;AACjD,SAAO;AACT;AACA,iBAAiB,iBAAiB;AAChC,QAAM,YAAY,aAAa,MAAM,SAAS,IAAI,aAAa,MAAM,SAAS,EAAE,aAAa,aAAa,MAAM,oBAAoB,IAAI,KAAK,IAAI,IAAI;AACrJ,MAAI,YAAY,GAAG;AACjB,WAAO,aAAa,MAAM,SAAS,EAAE;AAAA,EACvC;AACA,MAAI,aAAa,MAAM,SAAS,GAAG;AACjC,UAAM,kBAAkB,KAAK;AAAA,MAC3B,aAAa,MAAM,SAAS,EAAE,aAAa,aAAa,MAAM,oBAAoB,IAAI,KAAK,IAAI;AAAA,MAC/F;AAAA,IACF;AACA,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,eAAe,CAAC;AAAA,EACrE;AACA,QAAM,QAAQ,MAAM,aAAa,MAAMA,QAAO,EAAE,wBAAwB;AACxE,eAAa,MAAM,WAAW;AAAA,IAC5B,OAAO,OAAO,MAAM,iBAAiB;AAAA,IACrC,YAAY,OAAO,SAAS,MAAM,uBAAuB,EAAE,IAAI,OAAO,SAAS,MAAM,iBAAiB,EAAE;AAAA,EAC1G,CAAC;AACD,SAAO,gBAAgB,MAAM,wCAAwC,cAAc,EAAE,KAAK,IAAI;AAChG;AACA,oBAAoB,iBAAiB;AACnC,QAAM,YAAY,KAAK;AAAA,IACrB,aAAa,MAAM,cAAc;AAAA,IACjC,aAAa,MAAM,YAAY,KAAK,aAAa,MAAM,SAAS,EAAE,SAAS,aAAa,MAAM,oBAAoB,KAAK;AAAA,EACzH;AACA,MAAI,cAAc,GAAG;AACnB;AAAA,EACF;AACA,QAAM,MAAM,IAAI,YAAY;AAC5B,QAAM,UAAU,aAAa,MAAMD,QAAO,EAAE,aAAa;AACzD,MAAI,UAAU,OAAO;AACrB,MAAI,aAAa,MAAM,YAAY,GAAG;AACpC,UAAM,OAAO,CAAC;AACd,UAAM,MAAM,CAAC;AACb,eAAW,CAAC,IAAI,GAAG,KAAK,aAAa,MAAM,YAAY,GAAG;AACxD,UAAI,KAAK;AACP,aAAK,KAAK,GAAG;AAAA,MACf,OAAO;AACL,YAAI,KAAK,EAAE;AAAA,MACb;AAAA,IACF;AACA,QAAI,IAAI,SAAS,GAAG;AAClB,YAAM,QAAQ,MAAM,aAAa,MAAMC,QAAO,EAAE,gBAAgB;AAAA,QAC9D;AAAA,MACF,CAAC;AACD,WAAK;AAAA,QACH,GAAG,MAAM,OAAO,CAAC,SAAS,KAAK,SAAS,IAAI,EAAE,IAAI,CAAC,EAAE,KAAK,OAAO;AAAA,UAC/D,UAAU,KAAK;AAAA,UACf,SAAS,KAAK;AAAA,UACd,QAAQ,KAAK;AAAA,QACf,EAAE;AAAA,MACJ;AAAA,IACF;AACA,QAAI,cAAc,IAAI;AACtB,iBAAa,MAAM,cAA8B,oBAAI,IAAI,CAAC;AAAA,EAC5D;AACA,QAAM,UAAU,IAAI,MAAM,SAAS,EAAE,KAAK,aAAa,MAAM,mBAAmB,CAAC;AACjF,QAAM,UAAU,IAAI,WAAW,IAAI,KAAK,OAAO;AAC/C,QAAM,cAAc,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,gBAAY,KAAK,QAAQ,CAAC,CAAC;AAAA,EAC7B;AACA,MAAI,gBAAgB,aAAa,OAAO;AACxC,QAAM,KAAK,uBAAuB;AAClC,QAAM,SAAS,MAAM,aAAa,MAAMA,QAAO,EAAE,0BAA0B;AAAA,IACzE,aAAa;AAAA,IACb,QAAQ,aAAa,MAAMD,QAAO;AAAA,IAClC,SAAS;AAAA,MACP,gBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AACD,QAAM,UAAU,OAAI,mBAAmB,MAAM,WAAW,KAAK,OAAO,UAAU,CAAC;AAC/E,UAAQ,IAAI,eAAe,QAAQ,CAAC,CAAC,IAAI,EAAE,YAAY,CAAC,GAAG,MAAM;AAC/D,QAAI,MAAM,QAAQ,IAAI,kBAAkB,CAAC,YAAY,aAAa;AAChE;AAAA,IACF;AACA,iBAAa,MAAM,SAAS,EAAE,KAAK;AAAA,MACjC;AAAA,MACA,SAAS,QAAQ,GAAG;AAAA,MACpB,QAAQ,YAAY,YAAY,CAAC;AAAA,MACjC,SAAS,OAAO,aAAa,MAAM,mBAAmB,CAAC;AAAA,IACzD,CAAC;AAAA,EACH,CAAC;AACD,MAAI,CAAC,aAAa,MAAM,YAAY,GAAG;AACrC,iBAAa,MAAM,cAA8B,oBAAI,IAAI,CAAC;AAAA,EAC5D;AACA,QAAM,YAAY,sBAAsB,OAAO,EAAE;AACjD,eAAa,MAAM,YAAY,EAAE,IAAI,UAAU,UAAU,SAAS;AAClE,QAAM,aAAa,MAAMC,QAAO,EAAE,mBAAmB,EAAE,QAAQ,OAAO,OAAO,CAAC;AAChF;;;AC5VA,IAAM,WAAW,mBAAmB,eAAe;AA0BnD,IAAM,sBAAsB,OAAO;AAAA,EACjC,MAAM,OAAO;AAAA,EACb,SAAS,OAAO;AAClB,CAAC;;;AClCD,IAAM,YAAY;AAAA,EAChB,MAAM,WAAW,CAAC,UAAU,CAAC,OAAO,GAAG,KAAK,KAAK,CAAC;AAAA,EAClD,QAAQ,oBAAoB,CAAC,UAAU,CAAC,OAAO,GAAG,OAAO,KAAK,CAAC;AAAA,EAC/D,iBAAiB,IAAI,SAAS,CAAC,OAAO,GAAG,gBAAgB,GAAG,IAAI;AAAA,EAChE,WAAW,IAAI,SAAS,CAAC,OAAO,GAAG,UAAU,GAAG,IAAI;AAAA,EACpD,cAAc,IAAI,SAAS,CAAC,OAAO,GAAG,aAAa,GAAG,IAAI;AAC5D;;;ACLA,eAAe,0BAA0B,QAAQ,OAAO;AACtD,MAAI,OAAO,SAAS,+BAA+B,GAAG;AACpD,WAAO,OAAO,SAAS,+BAA+B,EAAE,0BAA0B,KAAK;AAAA,EACzF;AACA,MAAI,CAAC,OAAO,SAAS,oCAAoC,GAAG;AAC1D,UAAM,IAAI;AAAA,MACR,oBAAoB,OAAO,IAAI;AAAA,IACjC;AAAA,EACF;AACA,QAAM,EAAE,+BAA+B,IAAI,OAAO,SAAS,oCAAoC;AAC/F,QAAM,mBAAmB,YAAY,KAAK,MAAM,MAAM,YAAY,OAAO,CAAC;AAC1E,QAAM,EAAE,QAAQ,YAAY,eAAe,IAAI,MAAM,+BAA+B;AAAA,IAClF,SAAS,MAAM;AAAA,IACf,OAAO,MAAM;AAAA,IACb;AAAA,IACA,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,cAAc;AAAA,IAChB;AAAA,EACF,CAAC;AACD,QAAM;AAAA,IACJ;AAAA,MACE,cAAc,CAAC,SAAS;AAAA,MACxB,eAAe,EAAE,OAAO,eAAe;AAAA,IACzC;AAAA,EACF,IAAI,OAAI,iBAAiB,MAAM,WAAW,cAAc,CAAC;AACzD,QAAM,QAAQ,OAAI,gBAAgB,UAAU,cAAc,EAAE,SAAS;AACrE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,SAAS,IAAI,WAAW,UAAU,CAAC;AAAA,EAC9C;AACF;AACA,eAAe,gBAAgB,QAAQ,OAAO;AAC5C,MAAI,OAAO,SAAS,qBAAqB,GAAG;AAC1C,WAAO,OAAO,SAAS,qBAAqB,EAAE,gBAAgB,KAAK;AAAA,EACrE;AACA,MAAI,CAAC,OAAO,SAAS,0BAA0B,GAAG;AAChD,UAAM,IAAI;AAAA,MACR,oBAAoB,OAAO,IAAI;AAAA,IACjC;AAAA,EACF;AACA,QAAM,EAAE,qBAAqB,IAAI,OAAO,SAAS,0BAA0B;AAC3E,QAAM,cAAc,YAAY,KAAK,MAAM,MAAM,YAAY,OAAO,CAAC;AACrE,QAAM,EAAE,uBAAuB,UAAU,IAAI,MAAM,qBAAqB;AAAA,IACtE,kBAAkB;AAAA,IAClB,SAAS,MAAM;AAAA,IACf,OAAO,MAAM;AAAA,EACf,CAAC;AACD,SAAO,EAAE,OAAO,uBAAuB,UAAU;AACnD;;;ACtDA,IAAM,iBAAiB;;;ACAvB,IAAM,0BAA0B;;;ACAhC,IAAM,qBAAqB;;;ACA3B,IAAM,oCAAoC;;;ACA1C,IAAM,+BAA+B;;;ACArC,IAAM,yBAAyB;;;ACA/B,IAAM,8BAA8B;;;ACApC,IAAM,qBAAqB;;;ACC3B,IAAM,oBAAoB,CAAC,iBAAiB,cAAc;AAC1D,SAAS,+BAA+B,QAAQ,qBAAqB,CAAC,GAAG;AACvE,SAAO,CAAC,GAAG,mBAAmB,GAAG,kBAAkB,EAAE;AAAA,IACnD,CAAC,YAAY,WAAW,OAAO;AAAA,EACjC;AACF;;;ACNA,IAAM,mBAAmB;AACzB,IAAM,oBAAoB;AAC1B,IAAM,qBAAqB;AAC3B,IAAM,oBAAoB;AAC1B,IAAM,aAAa;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,SAAS,WAAW,OAAO;AACzB,SAAO,WAAW,SAAS,KAAK;AAClC;",
  "names": ["wallets", "register", "callbacks", "StateType", "isWalletStandardError", "__classPrivateFieldGet", "__classPrivateFieldSet", "register", "__classPrivateFieldGet", "__classPrivateFieldSet", "length", "bytes", "guard", "_queue", "_cache", "_queue", "_cache", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest"]
}
