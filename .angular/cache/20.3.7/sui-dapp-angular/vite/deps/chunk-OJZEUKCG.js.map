{
  "version": 3,
  "sources": ["../../../../../../node_modules/@mysten/sui/dist/esm/transactions/serializer.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/Inputs.js", "../../../../../../node_modules/valibot/dist/index.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/data/internal.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/Commands.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/data/v1.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/hash.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/utils.js", "../../../../../../node_modules/@mysten/sui/dist/esm/experimental/cache.js", "../../../../../../node_modules/@mysten/sui/dist/esm/version.js", "../../../../../../node_modules/@mysten/sui/dist/esm/experimental/mvr.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/plugins/NamedPackagesPlugin.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/data/v2.js", "../../../../../../node_modules/@mysten/sui/dist/esm/jsonRpc/json-rpc-resolver.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/resolve.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/object.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/pure.js", "../../../../../../node_modules/@mysten/sui/dist/esm/transactions/Transaction.js"],
  "sourcesContent": ["import { bcs } from \"../bcs/index.js\";\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from \"../utils/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst OBJECT_MODULE_NAME = \"object\";\nconst ID_STRUCT_NAME = \"ID\";\nconst STD_ASCII_MODULE_NAME = \"ascii\";\nconst STD_ASCII_STRUCT_NAME = \"String\";\nconst STD_UTF8_MODULE_NAME = \"string\";\nconst STD_UTF8_STRUCT_NAME = \"String\";\nconst STD_OPTION_MODULE_NAME = \"option\";\nconst STD_OPTION_STRUCT_NAME = \"Option\";\nfunction isTxContext(param) {\n  const struct = typeof param.body === \"object\" && \"datatype\" in param.body ? param.body.datatype : null;\n  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress(\"0x2\") && struct.module === \"tx_context\" && struct.type === \"TxContext\";\n}\nfunction getPureBcsSchema(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    if (typeSignature.vector === \"u8\") {\n      return bcs.byteVector().transform({\n        input: (val) => typeof val === \"string\" ? new TextEncoder().encode(val) : val,\n        output: (val) => val\n      });\n    }\n    const type = getPureBcsSchema(typeSignature.vector);\n    return type ? bcs.vector(type) : null;\n  }\n  if (\"datatype\" in typeSignature) {\n    const pkg = normalizeSuiAddress(typeSignature.datatype.package);\n    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {\n        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n        return type ? bcs.vector(type) : null;\n      }\n    }\n    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {\n      return bcs.Address;\n    }\n  }\n  return null;\n}\nfunction normalizedTypeToMoveTypeSignature(type) {\n  if (typeof type === \"object\" && \"Reference\" in type) {\n    return {\n      ref: \"&\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)\n    };\n  }\n  if (typeof type === \"object\" && \"MutableReference\" in type) {\n    return {\n      ref: \"&mut\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)\n    };\n  }\n  return {\n    ref: null,\n    body: normalizedTypeToMoveTypeSignatureBody(type)\n  };\n}\nfunction normalizedTypeToMoveTypeSignatureBody(type) {\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"Address\":\n        return \"address\";\n      case \"Bool\":\n        return \"bool\";\n      case \"U8\":\n        return \"u8\";\n      case \"U16\":\n        return \"u16\";\n      case \"U32\":\n        return \"u32\";\n      case \"U64\":\n        return \"u64\";\n      case \"U128\":\n        return \"u128\";\n      case \"U256\":\n        return \"u256\";\n      default:\n        throw new Error(`Unexpected type ${type}`);\n    }\n  }\n  if (\"Vector\" in type) {\n    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n  }\n  if (\"Struct\" in type) {\n    return {\n      datatype: {\n        package: type.Struct.address,\n        module: type.Struct.module,\n        type: type.Struct.name,\n        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)\n      }\n    };\n  }\n  if (\"TypeParameter\" in type) {\n    return { typeParameter: type.TypeParameter };\n  }\n  throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\nfunction pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n  }\n  throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\nexport {\n  getPureBcsSchema,\n  isTxContext,\n  normalizedTypeToMoveTypeSignature,\n  pureBcsSchemaFromOpenMoveTypeSignatureBody\n};\n\n", "import { toBase64 } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nfunction Pure(data) {\n  return {\n    $kind: \"Pure\",\n    Pure: {\n      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()\n    }\n  };\n}\nconst Inputs = {\n  Pure,\n  ObjectRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"ImmOrOwnedObject\",\n        ImmOrOwnedObject: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  SharedObjectRef({\n    objectId,\n    mutable,\n    initialSharedVersion\n  }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"SharedObject\",\n        SharedObject: {\n          mutable,\n          initialSharedVersion,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  ReceivingRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"Receiving\",\n        Receiving: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  }\n};\nexport {\n  Inputs\n};\n\n", "// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = await pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n", "import {\n  array,\n  boolean,\n  check,\n  integer,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  transform,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { isValidSuiAddress, normalizeSuiAddress } from \"../../utils/sui-types.js\";\nfunction safeEnum(options) {\n  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n  return pipe(\n    union(unionOptions),\n    transform((value) => ({\n      ...value,\n      $kind: Object.keys(value)[0]\n    }))\n  );\n}\nconst SuiAddress = pipe(\n  string(),\n  transform((value) => normalizeSuiAddress(value)),\n  check(isValidSuiAddress)\n);\nconst ObjectID = SuiAddress;\nconst BCSBytes = string();\nconst JsonU64 = pipe(\n  union([string(), pipe(number(), integer())]),\n  check((val) => {\n    try {\n      BigInt(val);\n      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n    } catch {\n      return false;\n    }\n  }, \"Invalid u64\")\n);\nconst ObjectRefSchema = object({\n  objectId: SuiAddress,\n  version: JsonU64,\n  digest: string()\n});\nconst ArgumentSchema = pipe(\n  union([\n    object({ GasCoin: literal(true) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"pure\")) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"object\")) }),\n    object({ Result: pipe(number(), integer()) }),\n    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })\n  ]),\n  transform((value) => ({\n    ...value,\n    $kind: Object.keys(value)[0]\n  }))\n  // Defined manually to add `type?: 'pure' | 'object'` to Input\n);\nconst GasDataSchema = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRefSchema))\n});\nconst StructTagSchema = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  // type_params in rust, should be updated to use camelCase\n  typeParams: array(string())\n});\nconst OpenMoveTypeSignatureBodySchema = union([\n  literal(\"address\"),\n  literal(\"bool\"),\n  literal(\"u8\"),\n  literal(\"u16\"),\n  literal(\"u32\"),\n  literal(\"u64\"),\n  literal(\"u128\"),\n  literal(\"u256\"),\n  object({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),\n  object({\n    datatype: object({\n      package: string(),\n      module: string(),\n      type: string(),\n      typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))\n    })\n  }),\n  object({ typeParameter: pipe(number(), integer()) })\n]);\nconst OpenMoveTypeSignatureSchema = object({\n  ref: nullable(union([literal(\"&\"), literal(\"&mut\")])),\n  body: OpenMoveTypeSignatureBodySchema\n});\nconst ProgrammableMoveCallSchema = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(ArgumentSchema),\n  _argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n  data: record(string(), unknown())\n});\nconst CommandSchema = safeEnum({\n  MoveCall: ProgrammableMoveCallSchema,\n  TransferObjects: object({\n    objects: array(ArgumentSchema),\n    address: ArgumentSchema\n  }),\n  SplitCoins: object({\n    coin: ArgumentSchema,\n    amounts: array(ArgumentSchema)\n  }),\n  MergeCoins: object({\n    destination: ArgumentSchema,\n    sources: array(ArgumentSchema)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(ArgumentSchema)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: ArgumentSchema\n  }),\n  $Intent\n});\nconst ObjectArgSchema = safeEnum({\n  ImmOrOwnedObject: ObjectRefSchema,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRefSchema\n});\nconst CallArgSchema = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64)),\n    mutable: optional(nullable(boolean()))\n  })\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  })\n});\nconst TransactionExpiration = safeEnum({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst TransactionDataSchema = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasDataSchema,\n  inputs: array(CallArgSchema),\n  commands: array(CommandSchema)\n});\nexport {\n  $Intent,\n  ArgumentSchema,\n  BCSBytes,\n  CommandSchema,\n  GasDataSchema,\n  JsonU64,\n  NormalizedCallArg,\n  ObjectArgSchema,\n  ObjectID,\n  ObjectRefSchema,\n  OpenMoveTypeSignatureBodySchema,\n  OpenMoveTypeSignatureSchema,\n  StructTagSchema,\n  SuiAddress,\n  TransactionDataSchema,\n  TransactionExpiration,\n  safeEnum\n};\n\n", "import { toBase64 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nvar UpgradePolicy = /* @__PURE__ */ ((UpgradePolicy2) => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nconst Commands = {\n  MoveCall(input) {\n    const [pkg, mod = \"\", fn = \"\"] = \"target\" in input ? input.target.split(\"::\") : [input.package, input.module, input.function];\n    return {\n      $kind: \"MoveCall\",\n      MoveCall: {\n        package: pkg,\n        module: mod,\n        function: fn,\n        typeArguments: input.typeArguments ?? [],\n        arguments: input.arguments ?? []\n      }\n    };\n  },\n  TransferObjects(objects, address) {\n    return {\n      $kind: \"TransferObjects\",\n      TransferObjects: {\n        objects: objects.map((o) => parse(ArgumentSchema, o)),\n        address: parse(ArgumentSchema, address)\n      }\n    };\n  },\n  SplitCoins(coin, amounts) {\n    return {\n      $kind: \"SplitCoins\",\n      SplitCoins: {\n        coin: parse(ArgumentSchema, coin),\n        amounts: amounts.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  MergeCoins(destination, sources) {\n    return {\n      $kind: \"MergeCoins\",\n      MergeCoins: {\n        destination: parse(ArgumentSchema, destination),\n        sources: sources.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Publish({\n    modules,\n    dependencies\n  }) {\n    return {\n      $kind: \"Publish\",\n      Publish: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))\n      }\n    };\n  },\n  Upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return {\n      $kind: \"Upgrade\",\n      Upgrade: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n        package: packageId,\n        ticket: parse(ArgumentSchema, ticket)\n      }\n    };\n  },\n  MakeMoveVec({\n    type,\n    elements\n  }) {\n    return {\n      $kind: \"MakeMoveVec\",\n      MakeMoveVec: {\n        type: type ?? null,\n        elements: elements.map((o) => parse(ArgumentSchema, o))\n      }\n    };\n  },\n  Intent({\n    name,\n    inputs = {},\n    data = {}\n  }) {\n    return {\n      $kind: \"$Intent\",\n      $Intent: {\n        name,\n        inputs: Object.fromEntries(\n          Object.entries(inputs).map(([key, value]) => [\n            key,\n            Array.isArray(value) ? value.map((o) => parse(ArgumentSchema, o)) : parse(ArgumentSchema, value)\n          ])\n        ),\n        data\n      }\n    };\n  }\n};\nexport {\n  Commands,\n  UpgradePolicy\n};\n\n", "import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport {\n  array,\n  bigint,\n  boolean,\n  check,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  parse,\n  pipe,\n  string,\n  union,\n  unknown\n} from \"valibot\";\nimport { TypeTagSerializer } from \"../../bcs/index.js\";\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from \"./internal.js\";\nconst ObjectRef = object({\n  digest: string(),\n  objectId: string(),\n  version: union([pipe(number(), integer()), string(), bigint()])\n});\nconst ObjectArg = safeEnum({\n  ImmOrOwned: ObjectRef,\n  Shared: object({\n    objectId: ObjectID,\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: array(pipe(number(), integer()))\n});\nconst TransactionInput = union([\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: optional(literal(\"object\"))\n  }),\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: literal(\"pure\")\n  })\n]);\nconst TransactionExpiration = union([\n  object({ Epoch: pipe(number(), integer()) }),\n  object({ None: nullable(literal(true)) })\n]);\nconst StringEncodedBigint = pipe(\n  union([number(), string(), bigint()]),\n  check((val) => {\n    if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n    try {\n      BigInt(val);\n      return true;\n    } catch {\n      return false;\n    }\n  })\n);\nconst TypeTag = union([\n  object({ bool: nullable(literal(true)) }),\n  object({ u8: nullable(literal(true)) }),\n  object({ u64: nullable(literal(true)) }),\n  object({ u128: nullable(literal(true)) }),\n  object({ address: nullable(literal(true)) }),\n  object({ signer: nullable(literal(true)) }),\n  object({ vector: lazy(() => TypeTag) }),\n  object({ struct: lazy(() => StructTag) }),\n  object({ u16: nullable(literal(true)) }),\n  object({ u32: nullable(literal(true)) }),\n  object({ u256: nullable(literal(true)) })\n]);\nconst StructTag = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  typeParams: array(TypeTag)\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(ObjectRef)),\n  owner: optional(string())\n});\nconst TransactionArgumentTypes = [\n  TransactionInput,\n  object({ kind: literal(\"GasCoin\") }),\n  object({ kind: literal(\"Result\"), index: pipe(number(), integer()) }),\n  object({\n    kind: literal(\"NestedResult\"),\n    index: pipe(number(), integer()),\n    resultIndex: pipe(number(), integer())\n  })\n];\nconst TransactionArgument = union([...TransactionArgumentTypes]);\nconst MoveCallTransaction = object({\n  kind: literal(\"MoveCall\"),\n  target: pipe(\n    string(),\n    check((target) => target.split(\"::\").length === 3)\n  ),\n  typeArguments: array(string()),\n  arguments: array(TransactionArgument)\n});\nconst TransferObjectsTransaction = object({\n  kind: literal(\"TransferObjects\"),\n  objects: array(TransactionArgument),\n  address: TransactionArgument\n});\nconst SplitCoinsTransaction = object({\n  kind: literal(\"SplitCoins\"),\n  coin: TransactionArgument,\n  amounts: array(TransactionArgument)\n});\nconst MergeCoinsTransaction = object({\n  kind: literal(\"MergeCoins\"),\n  destination: TransactionArgument,\n  sources: array(TransactionArgument)\n});\nconst MakeMoveVecTransaction = object({\n  kind: literal(\"MakeMoveVec\"),\n  type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n  objects: array(TransactionArgument)\n});\nconst PublishTransaction = object({\n  kind: literal(\"Publish\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string())\n});\nconst UpgradeTransaction = object({\n  kind: literal(\"Upgrade\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string()),\n  packageId: string(),\n  ticket: TransactionArgument\n});\nconst TransactionTypes = [\n  MoveCallTransaction,\n  TransferObjectsTransaction,\n  SplitCoinsTransaction,\n  MergeCoinsTransaction,\n  PublishTransaction,\n  UpgradeTransaction,\n  MakeMoveVecTransaction\n];\nconst TransactionType = union([...TransactionTypes]);\nconst SerializedTransactionDataV1 = object({\n  version: literal(1),\n  sender: optional(string()),\n  expiration: nullish(TransactionExpiration),\n  gasConfig: GasConfig,\n  inputs: array(TransactionInput),\n  transactions: array(TransactionType)\n});\nfunction serializeV1TransactionData(transactionData) {\n  const inputs = transactionData.inputs.map(\n    (input, index) => {\n      if (input.Object) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Object: input.Object.ImmOrOwnedObject ? {\n              ImmOrOwned: input.Object.ImmOrOwnedObject\n            } : input.Object.Receiving ? {\n              Receiving: {\n                digest: input.Object.Receiving.digest,\n                version: input.Object.Receiving.version,\n                objectId: input.Object.Receiving.objectId\n              }\n            } : {\n              Shared: {\n                mutable: input.Object.SharedObject.mutable,\n                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n                objectId: input.Object.SharedObject.objectId\n              }\n            }\n          },\n          type: \"object\"\n        };\n      }\n      if (input.Pure) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Pure: Array.from(fromBase64(input.Pure.bytes))\n          },\n          type: \"pure\"\n        };\n      }\n      if (input.UnresolvedPure) {\n        return {\n          kind: \"Input\",\n          type: \"pure\",\n          index,\n          value: input.UnresolvedPure.value\n        };\n      }\n      if (input.UnresolvedObject) {\n        return {\n          kind: \"Input\",\n          type: \"object\",\n          index,\n          value: input.UnresolvedObject.objectId\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }\n  );\n  return {\n    version: 1,\n    sender: transactionData.sender ?? void 0,\n    expiration: transactionData.expiration?.$kind === \"Epoch\" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,\n    gasConfig: {\n      owner: transactionData.gasData.owner ?? void 0,\n      budget: transactionData.gasData.budget ?? void 0,\n      price: transactionData.gasData.price ?? void 0,\n      payment: transactionData.gasData.payment ?? void 0\n    },\n    inputs,\n    transactions: transactionData.commands.map((command) => {\n      if (command.MakeMoveVec) {\n        return {\n          kind: \"MakeMoveVec\",\n          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n          objects: command.MakeMoveVec.elements.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.MergeCoins) {\n        return {\n          kind: \"MergeCoins\",\n          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.MoveCall) {\n        return {\n          kind: \"MoveCall\",\n          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n          typeArguments: command.MoveCall.typeArguments,\n          arguments: command.MoveCall.arguments.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.Publish) {\n        return {\n          kind: \"Publish\",\n          modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Publish.dependencies\n        };\n      }\n      if (command.SplitCoins) {\n        return {\n          kind: \"SplitCoins\",\n          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.TransferObjects) {\n        return {\n          kind: \"TransferObjects\",\n          objects: command.TransferObjects.objects.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          ),\n          address: convertTransactionArgument(command.TransferObjects.address, inputs)\n        };\n      }\n      if (command.Upgrade) {\n        return {\n          kind: \"Upgrade\",\n          modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Upgrade.dependencies,\n          packageId: command.Upgrade.package,\n          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)\n        };\n      }\n      throw new Error(`Unknown transaction ${Object.keys(command)}`);\n    })\n  };\n}\nfunction convertTransactionArgument(arg, inputs) {\n  if (arg.$kind === \"GasCoin\") {\n    return { kind: \"GasCoin\" };\n  }\n  if (arg.$kind === \"Result\") {\n    return { kind: \"Result\", index: arg.Result };\n  }\n  if (arg.$kind === \"NestedResult\") {\n    return { kind: \"NestedResult\", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n  }\n  if (arg.$kind === \"Input\") {\n    return inputs[arg.Input];\n  }\n  throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\nfunction transactionDataFromV1(data) {\n  return parse(TransactionDataSchema, {\n    version: 2,\n    sender: data.sender ?? null,\n    expiration: data.expiration ? \"Epoch\" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,\n    gasData: {\n      owner: data.gasConfig.owner ?? null,\n      budget: data.gasConfig.budget?.toString() ?? null,\n      price: data.gasConfig.price?.toString() ?? null,\n      payment: data.gasConfig.payment?.map((ref) => ({\n        digest: ref.digest,\n        objectId: ref.objectId,\n        version: ref.version.toString()\n      })) ?? null\n    },\n    inputs: data.inputs.map((input) => {\n      if (input.kind === \"Input\") {\n        if (is(NormalizedCallArg, input.value)) {\n          const value = parse(NormalizedCallArg, input.value);\n          if (value.Object) {\n            if (value.Object.ImmOrOwned) {\n              return {\n                Object: {\n                  ImmOrOwnedObject: {\n                    objectId: value.Object.ImmOrOwned.objectId,\n                    version: String(value.Object.ImmOrOwned.version),\n                    digest: value.Object.ImmOrOwned.digest\n                  }\n                }\n              };\n            }\n            if (value.Object.Shared) {\n              return {\n                Object: {\n                  SharedObject: {\n                    mutable: value.Object.Shared.mutable ?? null,\n                    initialSharedVersion: value.Object.Shared.initialSharedVersion,\n                    objectId: value.Object.Shared.objectId\n                  }\n                }\n              };\n            }\n            if (value.Object.Receiving) {\n              return {\n                Object: {\n                  Receiving: {\n                    digest: value.Object.Receiving.digest,\n                    version: String(value.Object.Receiving.version),\n                    objectId: value.Object.Receiving.objectId\n                  }\n                }\n              };\n            }\n            throw new Error(\"Invalid object input\");\n          }\n          return {\n            Pure: {\n              bytes: toBase64(new Uint8Array(value.Pure))\n            }\n          };\n        }\n        if (input.type === \"object\") {\n          return {\n            UnresolvedObject: {\n              objectId: input.value\n            }\n          };\n        }\n        return {\n          UnresolvedPure: {\n            value: input.value\n          }\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }),\n    commands: data.transactions.map((transaction) => {\n      switch (transaction.kind) {\n        case \"MakeMoveVec\":\n          return {\n            MakeMoveVec: {\n              type: \"Some\" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,\n              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        case \"MergeCoins\": {\n          return {\n            MergeCoins: {\n              destination: parseV1TransactionArgument(transaction.destination),\n              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"MoveCall\": {\n          const [pkg, mod, fn] = transaction.target.split(\"::\");\n          return {\n            MoveCall: {\n              package: pkg,\n              module: mod,\n              function: fn,\n              typeArguments: transaction.typeArguments,\n              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"Publish\": {\n          return {\n            Publish: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies\n            }\n          };\n        }\n        case \"SplitCoins\": {\n          return {\n            SplitCoins: {\n              coin: parseV1TransactionArgument(transaction.coin),\n              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"TransferObjects\": {\n          return {\n            TransferObjects: {\n              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n              address: parseV1TransactionArgument(transaction.address)\n            }\n          };\n        }\n        case \"Upgrade\": {\n          return {\n            Upgrade: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies,\n              package: transaction.packageId,\n              ticket: parseV1TransactionArgument(transaction.ticket)\n            }\n          };\n        }\n      }\n      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n    })\n  });\n}\nfunction parseV1TransactionArgument(arg) {\n  switch (arg.kind) {\n    case \"GasCoin\": {\n      return { GasCoin: true };\n    }\n    case \"Result\":\n      return { Result: arg.index };\n    case \"NestedResult\": {\n      return { NestedResult: [arg.index, arg.resultIndex] };\n    }\n    case \"Input\": {\n      return { Input: arg.index };\n    }\n  }\n}\nexport {\n  NormalizedCallArg,\n  ObjectRef,\n  SerializedTransactionDataV1,\n  StructTag,\n  TransactionArgument,\n  TypeTag,\n  serializeV1TransactionData,\n  transactionDataFromV1\n};\n\n", "import { blake2b } from \"@noble/hashes/blake2b\";\nfunction hashTypedData(typeTag, data) {\n  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(data, typeTagBytes.length);\n  return blake2b(dataWithTag, { dkLen: 32 });\n}\nexport {\n  hashTypedData\n};\n\n", "import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { TransactionDataSchema } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : { None: true },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize(\n      { V1: transactionData },\n      { maxSize: maxSizeBytes }\n    ).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return { Input: index, type, $kind: \"Input\" };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapCommandArguments(index, fn) {\n    const command = this.commands[index];\n    switch (command.$kind) {\n      case \"MoveCall\":\n        command.MoveCall.arguments = command.MoveCall.arguments.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"TransferObjects\":\n        command.TransferObjects.objects = command.TransferObjects.objects.map(\n          (arg) => fn(arg, command, index)\n        );\n        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n        break;\n      case \"SplitCoins\":\n        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n        command.SplitCoins.amounts = command.SplitCoins.amounts.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"MergeCoins\":\n        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n        command.MergeCoins.sources = command.MergeCoins.sources.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"MakeMoveVec\":\n        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(\n          (arg) => fn(arg, command, index)\n        );\n        break;\n      case \"Upgrade\":\n        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n        break;\n      case \"$Intent\":\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn(arg, command, index)) : fn(value, command, index);\n        }\n        break;\n      case \"Publish\":\n        break;\n      default:\n        throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n    }\n  }\n  mapArguments(fn) {\n    for (const commandIndex of this.commands.keys()) {\n      this.mapCommandArguments(commandIndex, fn);\n    }\n  }\n  replaceCommand(index, replacement, resultIndex = index) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...replacement);\n    if (sizeDiff !== 0) {\n      this.mapArguments((arg, _command, commandIndex) => {\n        if (commandIndex < index + replacement.length) {\n          return arg;\n        }\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result === index) {\n              arg.Result = resultIndex;\n            }\n            if (arg.Result > index) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] === index) {\n              arg.NestedResult[0] = resultIndex;\n            }\n            if (arg.NestedResult[0] > index) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({ onlyTransactionKind: false });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionDataSchema, this);\n  }\n  shallowClone() {\n    return new TransactionDataBuilder({\n      version: this.version,\n      sender: this.sender,\n      expiration: this.expiration,\n      gasData: {\n        ...this.gasData\n      },\n      inputs: [...this.inputs],\n      commands: [...this.commands]\n    });\n  }\n  applyResolvedData(resolved) {\n    if (!this.sender) {\n      this.sender = resolved.sender ?? null;\n    }\n    if (!this.expiration) {\n      this.expiration = resolved.expiration ?? null;\n    }\n    if (!this.gasData.budget) {\n      this.gasData.budget = resolved.gasData.budget;\n    }\n    if (!this.gasData.owner) {\n      this.gasData.owner = resolved.gasData.owner ?? null;\n    }\n    if (!this.gasData.payment) {\n      this.gasData.payment = resolved.gasData.payment;\n    }\n    if (!this.gasData.price) {\n      this.gasData.price = resolved.gasData.price;\n    }\n    for (let i = 0; i < this.inputs.length; i++) {\n      const input = this.inputs[i];\n      const resolvedInput = resolved.inputs[i];\n      switch (input.$kind) {\n        case \"UnresolvedPure\":\n          if (resolvedInput.$kind !== \"Pure\") {\n            throw new Error(\n              `Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n                resolvedInput\n              )}`\n            );\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n        case \"UnresolvedObject\":\n          if (resolvedInput.$kind !== \"Object\") {\n            throw new Error(\n              `Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n                resolvedInput\n              )}`\n            );\n          }\n          if (resolvedInput.Object.$kind === \"ImmOrOwnedObject\" || resolvedInput.Object.$kind === \"Receiving\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest || // Objects with shared object properties should not resolve to owned objects\n            original.mutable != null || original.initialSharedVersion != null) {\n              throw new Error(\n                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`\n              );\n            }\n          } else if (resolvedInput.Object.$kind === \"SharedObject\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.SharedObject;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable || // Objects with owned object properties should not resolve to shared objects\n            original.version != null || original.digest != null) {\n              throw new Error(\n                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`\n              );\n            }\n          } else {\n            throw new Error(\n              `Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n                resolvedInput.Object\n              )}`\n            );\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n      }\n    }\n  }\n}\nexport {\n  TransactionDataBuilder\n};\n\n", "import { is } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nfunction extractMutableReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"MutableReference\" in normalizedType ? normalizedType.MutableReference : void 0;\n}\nfunction extractReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"Reference\" in normalizedType ? normalizedType.Reference : void 0;\n}\nfunction extractStructTag(normalizedType) {\n  if (typeof normalizedType === \"object\" && \"Struct\" in normalizedType) {\n    return normalizedType;\n  }\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n  if (typeof ref === \"object\" && \"Struct\" in ref) {\n    return ref;\n  }\n  if (typeof mutRef === \"object\" && \"Struct\" in mutRef) {\n    return mutRef;\n  }\n  return void 0;\n}\nfunction getIdFromCallArg(arg) {\n  if (typeof arg === \"string\") {\n    return normalizeSuiAddress(arg);\n  }\n  if (arg.Object) {\n    if (arg.Object.ImmOrOwnedObject) {\n      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n    }\n    if (arg.Object.Receiving) {\n      return normalizeSuiAddress(arg.Object.Receiving.objectId);\n    }\n    return normalizeSuiAddress(arg.Object.SharedObject.objectId);\n  }\n  if (arg.UnresolvedObject) {\n    return normalizeSuiAddress(arg.UnresolvedObject.objectId);\n  }\n  return void 0;\n}\nfunction isArgument(value) {\n  return is(ArgumentSchema, value);\n}\nexport {\n  extractMutableReference,\n  extractReference,\n  extractStructTag,\n  getIdFromCallArg,\n  isArgument\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _prefix, _cache;\nconst _ClientCache = class _ClientCache {\n  constructor({ prefix, cache } = {}) {\n    __privateAdd(this, _prefix);\n    __privateAdd(this, _cache);\n    __privateSet(this, _prefix, prefix ?? []);\n    __privateSet(this, _cache, cache ?? /* @__PURE__ */ new Map());\n  }\n  read(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    if (typeof result === \"object\" && result !== null && \"then\" in result) {\n      return Promise.resolve(result).then((v) => {\n        __privateGet(this, _cache).set(cacheKey, v);\n        return v;\n      }).catch((err) => {\n        __privateGet(this, _cache).delete(cacheKey);\n        throw err;\n      });\n    }\n    return result;\n  }\n  readSync(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    return result;\n  }\n  clear(prefix) {\n    const prefixKey = [...__privateGet(this, _prefix), ...prefix ?? []].join(\":\");\n    if (!prefixKey) {\n      __privateGet(this, _cache).clear();\n      return;\n    }\n    for (const key of __privateGet(this, _cache).keys()) {\n      if (key.startsWith(prefixKey)) {\n        __privateGet(this, _cache).delete(key);\n      }\n    }\n  }\n  scope(prefix) {\n    return new _ClientCache({\n      prefix: [...__privateGet(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],\n      cache: __privateGet(this, _cache)\n    });\n  }\n};\n_prefix = new WeakMap();\n_cache = new WeakMap();\nlet ClientCache = _ClientCache;\nexport {\n  ClientCache\n};\n\n", "const PACKAGE_VERSION = \"1.43.1\";\nconst TARGETED_RPC_VERSION = \"1.60.0\";\nexport {\n  PACKAGE_VERSION,\n  TARGETED_RPC_VERSION\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;\nimport { chunk, DataLoader } from \"@mysten/utils\";\nimport { isValidNamedPackage, isValidNamedType } from \"../utils/move-registry.js\";\nimport {\n  isValidSuiAddress,\n  normalizeStructTag,\n  normalizeSuiAddress,\n  parseStructTag\n} from \"../utils/sui-types.js\";\nimport { PACKAGE_VERSION } from \"../version.js\";\nconst NAME_SEPARATOR = \"/\";\nconst MVR_API_HEADER = {\n  \"Mvr-Source\": `@mysten/sui@${PACKAGE_VERSION}`\n};\nclass MvrClient {\n  constructor({ cache, url, pageSize = 50, overrides }) {\n    __privateAdd(this, _MvrClient_instances);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _url);\n    __privateAdd(this, _pageSize);\n    __privateAdd(this, _overrides);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _url, url);\n    __privateSet(this, _pageSize, pageSize);\n    __privateSet(this, _overrides, {\n      packages: overrides?.packages,\n      types: overrides?.types\n    });\n    validateOverrides(__privateGet(this, _overrides));\n  }\n  async resolvePackage({\n    package: name\n  }) {\n    if (!hasMvrName(name)) {\n      return {\n        package: name\n      };\n    }\n    const resolved = await __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);\n    return {\n      package: resolved\n    };\n  }\n  async resolveType({\n    type\n  }) {\n    if (!hasMvrName(type)) {\n      return {\n        type\n      };\n    }\n    const mvrTypes = [...extractMvrTypes(type)];\n    const resolvedTypes = await __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);\n    const typeMap = {};\n    for (let i = 0; i < mvrTypes.length; i++) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[mvrTypes[i]] = resolvedType;\n    }\n    return {\n      type: replaceMvrNames(type, typeMap)\n    };\n  }\n  async resolve({\n    types = [],\n    packages = []\n  }) {\n    const mvrTypes = /* @__PURE__ */ new Set();\n    for (const type of types ?? []) {\n      extractMvrTypes(type, mvrTypes);\n    }\n    const typesArray = [...mvrTypes];\n    const [resolvedTypes, resolvedPackages] = await Promise.all([\n      typesArray.length > 0 ? __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [],\n      packages.length > 0 ? __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []\n    ]);\n    const typeMap = {\n      ...__privateGet(this, _overrides)?.types\n    };\n    for (const [i, type] of typesArray.entries()) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[type] = resolvedType;\n    }\n    const replacedTypes = {};\n    for (const type of types ?? []) {\n      const resolvedType = replaceMvrNames(type, typeMap);\n      replacedTypes[type] = {\n        type: resolvedType\n      };\n    }\n    const replacedPackages = {};\n    for (const [i, pkg] of (packages ?? []).entries()) {\n      const resolvedPkg = __privateGet(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];\n      if (resolvedPkg instanceof Error) {\n        throw resolvedPkg;\n      }\n      replacedPackages[pkg] = {\n        package: resolvedPkg\n      };\n    }\n    return {\n      types: replacedTypes,\n      packages: replacedPackages\n    };\n  }\n}\n_cache = new WeakMap();\n_url = new WeakMap();\n_pageSize = new WeakMap();\n_overrides = new WeakMap();\n_MvrClient_instances = new WeakSet();\nmvrPackageDataLoader_get = function() {\n  return __privateGet(this, _cache).readSync([\"#mvrPackageDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async (packages) => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\n          `MVR Api URL is not set for the current client (resolving ${packages.join(\", \")})`\n        );\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);\n      return packages.map(\n        (pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`)\n      );\n    });\n    const overrides = __privateGet(this, _overrides)?.packages;\n    if (overrides) {\n      for (const [pkg, id] of Object.entries(overrides)) {\n        loader.prime(pkg, id);\n      }\n    }\n    return loader;\n  });\n};\nmvrTypeDataLoader_get = function() {\n  return __privateGet(this, _cache).readSync([\"#mvrTypeDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async (types) => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(\n          `MVR Api URL is not set for the current client (resolving ${types.join(\", \")})`\n        );\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);\n      return types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.types;\n    if (overrides) {\n      for (const [type, id] of Object.entries(overrides)) {\n        loader.prime(type, id);\n      }\n    }\n    return loader;\n  });\n};\nresolvePackages_fn = async function(packages) {\n  if (packages.length === 0) return {};\n  const batches = chunk(packages, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(\n    batches.map(async (batch) => {\n      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/resolution/bulk\", {\n        names: batch\n      });\n      if (!data?.resolution) return;\n      for (const pkg of Object.keys(data?.resolution)) {\n        const pkgData = data.resolution[pkg]?.package_id;\n        if (!pkgData) continue;\n        results[pkg] = pkgData;\n      }\n    })\n  );\n  return results;\n};\nresolveTypes_fn = async function(types) {\n  if (types.length === 0) return {};\n  const batches = chunk(types, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(\n    batches.map(async (batch) => {\n      const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/struct-definition/bulk\", {\n        types: batch\n      });\n      if (!data?.resolution) return;\n      for (const type of Object.keys(data?.resolution)) {\n        const typeData = data.resolution[type]?.type_tag;\n        if (!typeData) continue;\n        results[type] = typeData;\n      }\n    })\n  );\n  return results;\n};\nfetch_fn = async function(url, body) {\n  if (!__privateGet(this, _url)) {\n    throw new Error(\"MVR Api URL is not set for the current client\");\n  }\n  const response = await fetch(`${__privateGet(this, _url)}${url}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...MVR_API_HEADER\n    },\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) {\n    const errorBody = await response.json().catch(() => ({}));\n    throw new Error(`Failed to resolve types: ${errorBody?.message}`);\n  }\n  return response.json();\n};\nfunction validateOverrides(overrides) {\n  if (overrides?.packages) {\n    for (const [pkg, id] of Object.entries(overrides.packages)) {\n      if (!isValidNamedPackage(pkg)) {\n        throw new Error(`Invalid package name: ${pkg}`);\n      }\n      if (!isValidSuiAddress(normalizeSuiAddress(id))) {\n        throw new Error(`Invalid package ID: ${id}`);\n      }\n    }\n  }\n  if (overrides?.types) {\n    for (const [type, val] of Object.entries(overrides.types)) {\n      if (parseStructTag(type).typeParams.length > 0) {\n        throw new Error(\n          \"Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.\"\n        );\n      }\n      const parsedValue = parseStructTag(val);\n      if (!isValidSuiAddress(parsedValue.address)) {\n        throw new Error(`Invalid type: ${val}`);\n      }\n    }\n  }\n}\nfunction extractMvrTypes(type, types = /* @__PURE__ */ new Set()) {\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  const tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n  for (const param of tag.typeParams) {\n    extractMvrTypes(param, types);\n  }\n  return types;\n}\nfunction replaceMvrNames(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  const typeTag = `${type.address}::${type.module}::${type.name}`;\n  const cacheHit = typeCache[typeTag];\n  return normalizeStructTag({\n    ...type,\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache))\n  });\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nfunction findNamesInTransaction(builder) {\n  const packages = /* @__PURE__ */ new Set();\n  const types = /* @__PURE__ */ new Set();\n  for (const command of builder.commands) {\n    switch (command.$kind) {\n      case \"MakeMoveVec\":\n        if (command.MakeMoveVec.type) {\n          getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n            types.add(type);\n          });\n        }\n        break;\n      case \"MoveCall\":\n        const moveCall = command.MoveCall;\n        const pkg = moveCall.package.split(\"::\")[0];\n        if (hasMvrName(pkg)) {\n          if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n          packages.add(pkg);\n        }\n        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n          types.add(type);\n        });\n        break;\n      default:\n        break;\n    }\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction replaceNames(builder, resolved) {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!resolved.types[command.MakeMoveVec.type])\n        throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !resolved.packages[name])\n      throw new Error(`No address found for package: ${name}`);\n    if (hasMvrName(name)) {\n      nameParts[0] = resolved.packages[name].package;\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = resolved.types[types[i]].type;\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */ new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return names;\n}\nexport {\n  MvrClient,\n  extractMvrTypes,\n  findNamesInTransaction,\n  hasMvrName,\n  replaceNames\n};\n\n", "import { ClientCache } from \"../../experimental/cache.js\";\nimport { MvrClient } from \"../../experimental/mvr.js\";\nimport { findNamesInTransaction, replaceNames } from \"../../experimental/mvr.js\";\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nconst namedPackagesPlugin = (options) => {\n  let mvrClient;\n  if (options) {\n    const overrides = options.overrides ?? {\n      packages: {},\n      types: {}\n    };\n    if (!cacheMap.has(overrides)) {\n      cacheMap.set(overrides, new ClientCache());\n    }\n    mvrClient = new MvrClient({\n      cache: cacheMap.get(overrides),\n      url: options.url,\n      pageSize: options.pageSize,\n      overrides\n    });\n  }\n  return async (transactionData, buildOptions, next) => {\n    const names = findNamesInTransaction(transactionData);\n    if (names.types.length === 0 && names.packages.length === 0) {\n      return next();\n    }\n    const resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n      types: names.types,\n      packages: names.packages\n    });\n    replaceNames(transactionData, resolved);\n    await next();\n  };\n};\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\n      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`\n    );\n  }\n  return options.client;\n}\nexport {\n  getClient,\n  namedPackagesPlugin\n};\n\n", "import {\n  array,\n  boolean,\n  integer,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { BCSBytes, JsonU64, ObjectID, ObjectRefSchema, SuiAddress } from \"./internal.js\";\nfunction enumUnion(options) {\n  return union(\n    Object.entries(options).map(([key, value]) => object({ [key]: value }))\n  );\n}\nconst Argument = enumUnion({\n  GasCoin: literal(true),\n  Input: pipe(number(), integer()),\n  Result: pipe(number(), integer()),\n  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])\n});\nconst GasData = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRefSchema))\n});\nconst ProgrammableMoveCall = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(Argument)\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([Argument, array(Argument)])),\n  data: record(string(), unknown())\n});\nconst Command = enumUnion({\n  MoveCall: ProgrammableMoveCall,\n  TransferObjects: object({\n    objects: array(Argument),\n    address: Argument\n  }),\n  SplitCoins: object({\n    coin: Argument,\n    amounts: array(Argument)\n  }),\n  MergeCoins: object({\n    destination: Argument,\n    sources: array(Argument)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(Argument)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: Argument\n  }),\n  $Intent\n});\nconst ObjectArg = enumUnion({\n  ImmOrOwnedObject: ObjectRefSchema,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRefSchema\n});\nconst CallArg = enumUnion({\n  Object: ObjectArg,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64)),\n    mutable: optional(nullable(boolean()))\n  })\n});\nconst TransactionExpiration = enumUnion({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst SerializedTransactionDataV2Schema = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasData,\n  inputs: array(CallArg),\n  commands: array(Command),\n  digest: optional(nullable(string()))\n});\nexport {\n  SerializedTransactionDataV2Schema\n};\n\n", "import { parse } from \"valibot\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRefSchema } from \"../transactions/data/internal.js\";\nimport { Inputs } from \"../transactions/Inputs.js\";\nimport {\n  getPureBcsSchema,\n  isTxContext,\n  normalizedTypeToMoveTypeSignature\n} from \"../transactions/serializer.js\";\nimport { chunk } from \"@mysten/utils\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nfunction jsonRpcClientResolveTransactionPlugin(client) {\n  return async function resolveTransactionData(transactionData, options, next) {\n    await normalizeInputs(transactionData, client);\n    await resolveObjectReferences(transactionData, client);\n    if (!options.onlyTransactionKind) {\n      await setGasPrice(transactionData, client);\n      await setGasBudget(transactionData, client);\n      await setGasPayment(transactionData, client);\n    }\n    return await next();\n  };\n}\nasync function setGasPrice(transactionData, client) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, client) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await client.dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(\n      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n      { cause: dryRunResult }\n    );\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(\n    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead\n  );\n}\nasync function setGasPayment(transactionData, client) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await client.getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter((coin) => {\n      const matchingInput = transactionData.inputs.find((input) => {\n        if (input.Object?.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map((coin) => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map(\n      (payment) => parse(ObjectRefSchema, payment)\n    );\n  }\n}\nasync function resolveObjectReferences(transactionData, client) {\n  const objectsToResolve = transactionData.inputs.filter((input) => {\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);\n  });\n  const dedupedIds = [\n    ...new Set(\n      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))\n    )\n  ];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(\n    objectChunks.map(\n      (chunk2) => client.multiGetObjects({\n        ids: chunk2,\n        options: { showOwner: true }\n      })\n    )\n  )).flat();\n  const responsesById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, resolved[index]];\n    })\n  );\n  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));\n  if (invalidObjects.length) {\n    throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n  }\n  const objects = resolved.map((object) => {\n    if (object.error || !object.data) {\n      throw new Error(`Failed to fetch object: ${object.error}`);\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" ? \"Shared\" in owner ? owner.Shared.initial_shared_version : \"ConsensusAddressOwner\" in owner ? owner.ConsensusAddressOwner.start_version : null : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    })\n  );\n  for (const [index, input] of transactionData.inputs.entries()) {\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion,\n        mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      updated = Inputs.ReceivingRef(\n        {\n          objectId: id,\n          digest: input.UnresolvedObject.digest ?? object?.digest,\n          version: input.UnresolvedObject.version ?? object?.version\n        }\n      );\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({\n      objectId: id,\n      digest: input.UnresolvedObject.digest ?? object?.digest,\n      version: input.UnresolvedObject.version ?? object?.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, client) {\n  const { inputs, commands } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */ new Set();\n  commands.forEach((command) => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map((arg) => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(\n        (input) => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== \"boolean\"\n      );\n      if (needsResolution) {\n        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */ new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    await Promise.all(\n      [...moveFunctionsToResolve].map(async (functionName) => {\n        const [packageId, moduleId, functionId] = functionName.split(\"::\");\n        const def = await client.getNormalizedMoveFunction({\n          package: packageId,\n          module: moduleId,\n          function: functionId\n        });\n        moveFunctionParameters.set(\n          functionName,\n          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))\n        );\n      })\n    );\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(\n      moveCallsToResolve.map(async (moveCall) => {\n        const parameters = moveFunctionParameters.get(\n          `${moveCall.package}::${moveCall.module}::${moveCall.function}`\n        );\n        if (!parameters) {\n          return;\n        }\n        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n        moveCall._argumentTypes = params;\n      })\n    );\n  }\n  commands.forEach((command) => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(`Incorrect number of arguments for ${fnName}`);\n    }\n    params.forEach((param, i) => {\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(\n          `Expect the argument to be an object id string, got ${JSON.stringify(\n            inputValue,\n            null,\n            2\n          )}`\n        );\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\" || tx.$kind === \"TransferObjects\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nexport {\n  jsonRpcClientResolveTransactionPlugin\n};\n\n", "import { Inputs } from \"./Inputs.js\";\nimport { bcs } from \"../bcs/index.js\";\nimport { jsonRpcClientResolveTransactionPlugin } from \"../jsonRpc/json-rpc-resolver.js\";\nfunction needsTransactionResolution(data, options) {\n  if (data.inputs.some((input) => {\n    return input.UnresolvedObject || input.UnresolvedPure;\n  })) {\n    return true;\n  }\n  if (!options.onlyTransactionKind) {\n    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n      return true;\n    }\n  }\n  return false;\n}\nasync function resolveTransactionPlugin(transactionData, options, next) {\n  normalizeRawArguments(transactionData);\n  if (!needsTransactionResolution(transactionData, options)) {\n    await validate(transactionData);\n    return next();\n  }\n  const client = getClient(options);\n  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);\n  return plugin(transactionData, options, async () => {\n    await validate(transactionData);\n    await next();\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(\n        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n          input\n        )}`\n      );\n    }\n  });\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\n      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`\n    );\n  }\n  return options.client;\n}\nfunction normalizeRawArguments(transactionData) {\n  for (const command of transactionData.commands) {\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach((amount) => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  }\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nexport {\n  getClient,\n  needsTransactionResolution,\n  resolveTransactionPlugin\n};\n\n", "import { Inputs } from \"./Inputs.js\";\nfunction createObjectMethods(makeObject) {\n  function object(value) {\n    return makeObject(value);\n  }\n  object.system = (options) => {\n    const mutable = options?.mutable;\n    if (mutable !== void 0) {\n      return object(\n        Inputs.SharedObjectRef({\n          objectId: \"0x5\",\n          initialSharedVersion: 1,\n          mutable\n        })\n      );\n    }\n    return object({\n      $kind: \"UnresolvedObject\",\n      UnresolvedObject: {\n        objectId: \"0x5\",\n        initialSharedVersion: 1\n      }\n    });\n  };\n  object.clock = () => object(\n    Inputs.SharedObjectRef({\n      objectId: \"0x6\",\n      initialSharedVersion: 1,\n      mutable: false\n    })\n  );\n  object.random = () => object({\n    $kind: \"UnresolvedObject\",\n    UnresolvedObject: {\n      objectId: \"0x8\",\n      mutable: false\n    }\n  });\n  object.denyList = (options) => {\n    return object({\n      $kind: \"UnresolvedObject\",\n      UnresolvedObject: {\n        objectId: \"0x403\",\n        mutable: options?.mutable\n      }\n    });\n  };\n  object.option = ({ type, value }) => (tx) => tx.moveCall({\n    typeArguments: [type],\n    target: `0x1::option::${value === null ? \"none\" : \"some\"}`,\n    arguments: value === null ? [] : [tx.object(value)]\n  });\n  return object;\n}\nexport {\n  createObjectMethods\n};\n\n", "import { isSerializedBcs } from \"@mysten/bcs\";\nimport { bcs } from \"../bcs/index.js\";\nimport { pureBcsSchemaFromTypeName } from \"../bcs/pure.js\";\nfunction createPure(makePure) {\n  function pure(typeOrSerializedValue, value) {\n    if (typeof typeOrSerializedValue === \"string\") {\n      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));\n    }\n    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n      return makePure(typeOrSerializedValue);\n    }\n    throw new Error(\"tx.pure must be called either a bcs type name, or a serialized bcs value\");\n  }\n  pure.u8 = (value) => makePure(bcs.U8.serialize(value));\n  pure.u16 = (value) => makePure(bcs.U16.serialize(value));\n  pure.u32 = (value) => makePure(bcs.U32.serialize(value));\n  pure.u64 = (value) => makePure(bcs.U64.serialize(value));\n  pure.u128 = (value) => makePure(bcs.U128.serialize(value));\n  pure.u256 = (value) => makePure(bcs.U256.serialize(value));\n  pure.bool = (value) => makePure(bcs.Bool.serialize(value));\n  pure.string = (value) => makePure(bcs.String.serialize(value));\n  pure.address = (value) => makePure(bcs.Address.serialize(value));\n  pure.id = pure.address;\n  pure.vector = (type, value) => {\n    return makePure(\n      bcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value)\n    );\n  };\n  pure.option = (type, value) => {\n    return makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));\n  };\n  return pure;\n}\nexport {\n  createPure\n};\n\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _inputSection, _commandSection, _availableResults, _pendingPromises, _added, _data, _Transaction_instances, fork_fn, addCommand_fn, addInput_fn, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn, waitForPendingTasks_fn, sortCommandsAndInputs_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport {\n  ArgumentSchema,\n  NormalizedCallArg,\n  ObjectRefSchema,\n  TransactionExpiration\n} from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2Schema } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { needsTransactionResolution, resolveTransactionPlugin } from \"./resolve.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nimport { namedPackagesPlugin } from \"./plugins/NamedPackagesPlugin.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = {\n    $kind: \"Result\",\n    get Result() {\n      return typeof index === \"function\" ? index() : index;\n    }\n  };\n  const nestedResults = [];\n  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    get NestedResult() {\n      return [typeof index === \"function\" ? index() : index, resultIndex];\n    }\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\n        \"The transaction result is a proxy, and does not support setting properties directly\"\n      );\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */ new Map(),\n  serializationPlugins: /* @__PURE__ */ new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */ new Map());\n    __privateAdd(this, _inputSection, []);\n    __privateAdd(this, _commandSection, []);\n    __privateAdd(this, _availableResults, /* @__PURE__ */ new Set());\n    __privateAdd(this, _pendingPromises, /* @__PURE__ */ new Set());\n    __privateAdd(this, _added, /* @__PURE__ */ new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(\n      (value) => {\n        if (typeof value === \"function\") {\n          return this.object(this.add(value));\n        }\n        if (typeof value === \"object\" && is(ArgumentSchema, value)) {\n          return value;\n        }\n        const id = getIdFromCallArg(value);\n        const inserted = __privateGet(this, _data).inputs.find((i) => id === getIdFromCallArg(i));\n        if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n        }\n        return inserted ? { $kind: \"Input\", Input: __privateGet(this, _data).inputs.indexOf(inserted), type: \"object\" } : __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"object\", typeof value === \"string\" ? {\n          $kind: \"UnresolvedObject\",\n          UnresolvedObject: { objectId: normalizeSuiAddress(value) }\n        } : value);\n      }\n    );\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(\n      typeof serialized === \"string\" ? fromBase64(serialized) : serialized\n    ));\n    __privateSet(tx, _inputSection, __privateGet(tx, _data).inputs.slice());\n    __privateSet(tx, _commandSection, __privateGet(tx, _data).commands.slice());\n    __privateSet(tx, _availableResults, new Set(__privateGet(tx, _commandSection).map((_, i) => i)));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(\n        transaction.getData()\n      ));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(\n        typeof transaction === \"string\" ? fromBase64(transaction) : transaction\n      ));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    __privateSet(newTransaction, _inputSection, __privateGet(newTransaction, _data).inputs.slice());\n    __privateSet(newTransaction, _commandSection, __privateGet(newTransaction, _data).commands.slice());\n    __privateSet(newTransaction, _availableResults, new Set(__privateGet(newTransaction, _commandSection).map((_, i) => i)));\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure((value) => {\n        if (isSerializedBcs(value)) {\n          return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateMethod(this, _Transaction_instances, addInput_fn).call(this, \"pure\", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: \"UnresolvedPure\", UnresolvedPure: { value } });\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return { $kind: \"GasCoin\", GasCoin: true };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  add(command) {\n    if (typeof command === \"function\") {\n      if (__privateGet(this, _added).has(command)) {\n        return __privateGet(this, _added).get(command);\n      }\n      const fork = __privateMethod(this, _Transaction_instances, fork_fn).call(this);\n      const result = command(fork);\n      if (!(result && typeof result === \"object\" && \"then\" in result)) {\n        __privateSet(this, _availableResults, __privateGet(fork, _availableResults));\n        __privateGet(this, _added).set(command, result);\n        return result;\n      }\n      const placeholder = __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, {\n        $kind: \"$Intent\",\n        $Intent: {\n          name: \"AsyncTransactionThunk\",\n          inputs: {},\n          data: {\n            resultIndex: __privateGet(this, _data).commands.length,\n            result: null\n          }\n        }\n      });\n      __privateGet(this, _pendingPromises).add(\n        Promise.resolve(result).then((result2) => {\n          placeholder.$Intent.data.result = result2;\n        })\n      );\n      const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n      __privateGet(this, _added).set(command, txResult);\n      return txResult;\n    } else {\n      __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    }\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(\n      typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin),\n      amounts.map(\n        (amount) => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)\n      )\n    );\n    __privateMethod(this, _Transaction_instances, addCommand_fn).call(this, command);\n    return createTransactionResult(__privateGet(this, _data).commands.length - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(\n      Commands.MergeCoins(\n        this.object(destination),\n        sources.map((src) => this.object(src))\n      )\n    );\n  }\n  publish({ modules, dependencies }) {\n    return this.add(\n      Commands.Publish({\n        modules,\n        dependencies\n      })\n    );\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(\n      Commands.Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket: this.object(ticket)\n      })\n    );\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(\n      Commands.MoveCall({\n        ...input,\n        arguments: args?.map((arg) => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n      })\n    );\n  }\n  transferObjects(objects, address) {\n    return this.add(\n      Commands.TransferObjects(\n        objects.map((obj) => this.object(obj)),\n        typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)\n      )\n    );\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(\n      Commands.MakeMoveVec({\n        type,\n        elements: elements.map((obj) => this.object(obj))\n      })\n    );\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    const fullyResolved = this.isFullyResolved();\n    return JSON.stringify(\n      parse(\n        SerializedTransactionDataV2Schema,\n        fullyResolved ? {\n          ...__privateGet(this, _data).snapshot(),\n          digest: __privateGet(this, _data).getDigest()\n        } : __privateGet(this, _data).snapshot()\n      ),\n      (_key, value) => typeof value === \"bigint\" ? value.toString() : value,\n      2\n    );\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const { signer, ...buildOptions } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /**\n   *  Ensures that:\n   *  - All objects have been fully resolved to a specific version\n   *  - All pure inputs have been serialized to bytes\n   *  - All async thunks have been fully resolved\n   *  - All transaction intents have been resolved\n   * \t- The gas payment, budget, and price have been set\n   *  - The transaction sender has been set\n   *\n   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n   */\n  isFullyResolved() {\n    if (!__privateGet(this, _data).sender) {\n      return false;\n    }\n    if (__privateGet(this, _pendingPromises).size > 0) {\n      return false;\n    }\n    if (__privateGet(this, _data).commands.some((cmd) => cmd.$Intent)) {\n      return false;\n    }\n    if (needsTransactionResolution(__privateGet(this, _data), {})) {\n      return false;\n    }\n    return true;\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    await __privateMethod(this, _Transaction_instances, waitForPendingTasks_fn).call(this);\n    __privateMethod(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);\n    const intents = /* @__PURE__ */ new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    steps.push(namedPackagesPlugin());\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_inputSection = new WeakMap();\n_commandSection = new WeakMap();\n_availableResults = new WeakMap();\n_pendingPromises = new WeakMap();\n_added = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nfork_fn = function() {\n  const fork = new _Transaction();\n  __privateSet(fork, _data, __privateGet(this, _data));\n  __privateSet(fork, _serializationPlugins, __privateGet(this, _serializationPlugins));\n  __privateSet(fork, _buildPlugins, __privateGet(this, _buildPlugins));\n  __privateSet(fork, _intentResolvers, __privateGet(this, _intentResolvers));\n  __privateSet(fork, _pendingPromises, __privateGet(this, _pendingPromises));\n  __privateSet(fork, _availableResults, new Set(__privateGet(this, _availableResults)));\n  __privateSet(fork, _added, __privateGet(this, _added));\n  __privateGet(this, _inputSection).push(__privateGet(fork, _inputSection));\n  __privateGet(this, _commandSection).push(__privateGet(fork, _commandSection));\n  return fork;\n};\naddCommand_fn = function(command) {\n  const resultIndex = __privateGet(this, _data).commands.length;\n  __privateGet(this, _commandSection).push(command);\n  __privateGet(this, _availableResults).add(resultIndex);\n  __privateGet(this, _data).commands.push(command);\n  __privateGet(this, _data).mapCommandArguments(resultIndex, (arg) => {\n    if (arg.$kind === \"Result\" && !__privateGet(this, _availableResults).has(arg.Result)) {\n      throw new Error(\n        `Result { Result: ${arg.Result} } is not available to use the current transaction`\n      );\n    }\n    if (arg.$kind === \"NestedResult\" && !__privateGet(this, _availableResults).has(arg.NestedResult[0])) {\n      throw new Error(\n        `Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use the current transaction`\n      );\n    }\n    if (arg.$kind === \"Input\" && arg.Input >= __privateGet(this, _data).inputs.length) {\n      throw new Error(\n        `Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`\n      );\n    }\n    return arg;\n  });\n  return command;\n};\naddInput_fn = function(type, input) {\n  __privateGet(this, _inputSection).push(input);\n  return __privateGet(this, _data).addInput(type, input);\n};\nnormalizeTransactionArgument_fn = function(arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function(arg) {\n  if (typeof arg === \"function\") {\n    const resolved = this.add(arg);\n    if (typeof resolved === \"function\") {\n      return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);\n    }\n    return parse(ArgumentSchema, resolved);\n  }\n  return parse(ArgumentSchema, arg);\n};\nprepareBuild_fn = async function(options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionPlugin], options);\n};\nrunPlugins_fn = async function(plugins, options) {\n  try {\n    const createNext = (i) => {\n      if (i >= plugins.length) {\n        return () => {\n        };\n      }\n      const plugin = plugins[i];\n      return async () => {\n        const next = createNext(i + 1);\n        let calledNext = false;\n        let nextResolved = false;\n        await plugin(__privateGet(this, _data), options, async () => {\n          if (calledNext) {\n            throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n          }\n          calledNext = true;\n          await next();\n          nextResolved = true;\n        });\n        if (!calledNext) {\n          throw new Error(`next() was not called in TransactionPlugin ${i}`);\n        }\n        if (!nextResolved) {\n          throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n        }\n      };\n    };\n    await createNext(0)();\n  } finally {\n    __privateSet(this, _inputSection, __privateGet(this, _data).inputs.slice());\n    __privateSet(this, _commandSection, __privateGet(this, _data).commands.slice());\n  }\n};\nwaitForPendingTasks_fn = async function() {\n  while (__privateGet(this, _pendingPromises).size > 0) {\n    const newPromise = Promise.all(__privateGet(this, _pendingPromises));\n    __privateGet(this, _pendingPromises).clear();\n    __privateGet(this, _pendingPromises).add(newPromise);\n    await newPromise;\n    __privateGet(this, _pendingPromises).delete(newPromise);\n  }\n};\nsortCommandsAndInputs_fn = function() {\n  const unorderedCommands = __privateGet(this, _data).commands;\n  const unorderedInputs = __privateGet(this, _data).inputs;\n  const orderedCommands = __privateGet(this, _commandSection).flat(Infinity);\n  const orderedInputs = __privateGet(this, _inputSection).flat(Infinity);\n  if (orderedCommands.length !== unorderedCommands.length) {\n    throw new Error(\"Unexpected number of commands found in transaction data\");\n  }\n  if (orderedInputs.length !== unorderedInputs.length) {\n    throw new Error(\"Unexpected number of inputs found in transaction data\");\n  }\n  const filteredCommands = orderedCommands.filter(\n    (cmd) => cmd.$Intent?.name !== \"AsyncTransactionThunk\"\n  );\n  __privateGet(this, _data).commands = filteredCommands;\n  __privateGet(this, _data).inputs = orderedInputs;\n  __privateSet(this, _commandSection, filteredCommands);\n  __privateSet(this, _inputSection, orderedInputs);\n  __privateSet(this, _availableResults, new Set(filteredCommands.map((_, i) => i)));\n  function getOriginalIndex(index) {\n    const command = unorderedCommands[index];\n    if (command.$Intent?.name === \"AsyncTransactionThunk\") {\n      const result = command.$Intent.data.result;\n      if (result == null) {\n        throw new Error(\"AsyncTransactionThunk has not been resolved\");\n      }\n      return getOriginalIndex(result.Result);\n    }\n    const updated = filteredCommands.indexOf(command);\n    if (updated === -1) {\n      throw new Error(\"Unable to find original index for command\");\n    }\n    return updated;\n  }\n  __privateGet(this, _data).mapArguments((arg) => {\n    if (arg.$kind === \"Input\") {\n      const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n      if (updated === -1) {\n        throw new Error(\"Input has not been resolved\");\n      }\n      return { ...arg, Input: updated };\n    } else if (arg.$kind === \"Result\") {\n      const updated = getOriginalIndex(arg.Result);\n      return { ...arg, Result: updated };\n    } else if (arg.$kind === \"NestedResult\") {\n      const updated = getOriginalIndex(arg.NestedResult[0]);\n      return { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n    }\n    return arg;\n  });\n  for (const [i, cmd] of unorderedCommands.entries()) {\n    if (cmd.$Intent?.name === \"AsyncTransactionThunk\") {\n      try {\n        cmd.$Intent.data.resultIndex = getOriginalIndex(i);\n      } catch {\n      }\n    }\n  }\n};\nlet Transaction = _Transaction;\nexport {\n  Transaction,\n  isTransaction\n};\n\n"],
  "mappings": "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",
  "names": ["NormalizedCallArg", "TransactionExpiration", "_ClientCache", "__typeError", "__accessCheck", "__privateGet", "__privateAdd", "__privateSet", "_cache", "$Intent", "ObjectArg", "TransactionExpiration", "object", "getClient", "object", "__typeError", "__accessCheck", "__privateGet", "__privateAdd", "__privateSet", "__privateMethod", "_Transaction"]
}
